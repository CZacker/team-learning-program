## 题目 1429: [蓝桥杯][2014年第五届真题]兰顿蚂蚁

题目 1429: [蓝桥杯][2014年第五届真题]兰顿蚂蚁

时间限制: 1Sec 内存限制: 128MB 提交: 2854 解决: 1304

**题目描述**
![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dqdz7es1-1602340612833)(attachment:image.png)]](https://img-blog.csdnimg.cn/20201010223708317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU2OTc4NQ==,size_16,color_FFFFFF,t_70#pic_center)

兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。


平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。
蚂蚁的头部朝向为：上下左右其中一方。

蚂蚁的移动规则十分简单：

若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格；

若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。

规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。

蚂蚁的路线是很难事先预测的。

你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。

**输入**

输入数据的第一行是  m  n  两个整数（3  <   m,  n  <   100），表示正方形格子的行数和列数。 
接下来是  m  行数据。 

每行数据为  n  个被空格分开的数字。0  表示白格，1  表示黑格。 

接下来是一行数据：x  y  s  k,  其中x  y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。s  是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k  表示蚂蚁走的步数。 

**输出**

输出数据为一个空格分开的整数  p  q,  分别表示蚂蚁在k步后，所处格子的行号和列号。

**样例输入**
'''
5 6 
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 1 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
2 3 L 5
'''

样例输出
'''
1 3
'''



```
dir_dic={'U':0,'D':2,'L':3,'R':1}
direction=[[-1,0],[0,1],[1,0],[0,-1]]
dic_1={0:1,1:2,2:3,3:0}
dic_0={0:3,3:2,2:1,1:0}
m,n=map(int,input().strip().split())
map_=[]
for i in range(m):
    map_.append(input().strip().split())
x,y,s,k=input().strip().split()
x=int(x)
y=int(y)
s=dir_dic[s]
k=int(k)

for i in range(k):
    if map_[x][y]=='1':
        map_[x][y]='0'
        s=dic_1[s]
        tx,ty=direction[s]
        x+=tx
        y+=ty
        
#         for k in map_:
#             print(k)
#         print(x,y)
#         print(tx,ty)
#         print()
    elif map_[x][y]=='0':
        map_[x][y]='1'
        s=dic_0[s]
        tx,ty=direction[s]
        x+=tx
        y+=ty
#         for k in map_:
#             print(k)
#         print(x,y)
#         print(tx,ty)
#         print()
print(x,y)

```

    5 6 
    0 0 0 0 0 0 
    0 0 0 0 0 0 
    0 0 1 0 0 0 
    0 0 0 0 0 0 
    0 0 0 0 0 0 
    2 3 L 5
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    3 3
    1 0
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '0', '0']
    ['0', '0', '0', '1', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    3 4
    0 1
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '0', '0']
    ['0', '0', '0', '1', '1', '0']
    ['0', '0', '0', '0', '0', '0']
    2 4
    -1 0
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '1', '0']
    ['0', '0', '0', '1', '1', '0']
    ['0', '0', '0', '0', '0', '0']
    2 3
    0 -1
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '0', '1', '0']
    ['0', '0', '0', '1', '1', '0']
    ['0', '0', '0', '0', '0', '0']
    1 3
    -1 0
    
    1 3



```
import numpy as np
np.sum([[1,1,1],[2,2,2]])
```




    9




```
a=[[1,2],[5]]
max(a,key=len)
```




    [1, 2]




```
m,n=map()
```