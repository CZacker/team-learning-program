## 试题 算法训练 Sereja and Squares

提交此题   
资源限制
时间限制：4.0s   内存限制：256.0MB

**问题描述**
```
　　Sereja在平面上画了n个点，点i在坐标(i,0)。然后，Sereja给每个点标上了一个小写或大写英文字母。Sereja不喜欢字母"x"，所以他不用它标记点。Sereja认为这些点是漂亮的，当且仅当：
　　·所有的点可以被分成若干对，使得每个点恰好属于一一对之中。
　　·在每对点中，横坐标较小的会被标上小写字母，较大的会被标上对应的大写字母。
　　·如果我们在每对点上画一个正方形，其中已知的一对点会作为正方形的相对的顶点，它们间的线段会成为正方形的对角线，那么在所有画出的正方形中不会有相交或触碰的情况。
　　小Petya擦掉了一些小写字母和所有大写字母，现在Sereja想知道有多少种方法来还原每个点上的字母，使得还原后这些点是漂亮的。
```
**输入格式**
```
　　第一行是一个整数n，表示点的个数。
　　第二行是一个长度为n的字符串，包含小写字母和问号"?"，是按照横坐标递增的顺序的每个点的描述。问号表示这个点的字母被Petya擦掉了。保证输入串不含字母"x"。
```
**输出格式**
```
  输出答案对4294967296取模的值。如果没有可行的方案，输出0。
```

**样例输入**

```
4
a???
```

**样例输出**

```
50
```

**样例输入**

```
4
abc?
```

**样例输出**

```
0
```

**样例输入**

```
6
abc???

```

**样例输出**

```
1

```

**数据规模和约定**

```
　　20个测试点的n分别为：
　　5,10,20,50,100,
　　200,500,1000,2000,5000,
　　10000,20000,30000,40000,50000,
　　60000,70000,80000,90000,100000.
```


```
# print('a'>'b')
# print(ord('a'))
# print(ord('A'))
# print(ord('a')-ord('A'))
# print(ord('b')-ord('B'))
n=int(input())
s=list(input())
len_=0
re=1
label=0
temp2=26
for j in s:
    if j=='?':
        len_+=1
for i in range(n):
    if s[i]>='a'and s[i]<='z':
        temp2-=1
        if chr(ord(s[i])+32)in s[i:]:
            s.remove(chr(ord(s[i])+32))
        else:
            if len_<=0:
                label=1
                break
#             re*=len_
            len_-=1
#             print(re,len_)
            
# print('test1',re)
if len_%2!=0:
    label=1
else:
    temp=len_//2
    for i in range(temp):
        re*=temp2
        temp2-=1
#         temp-=1
print('test2',re)
if label ==1:
    print(0)
else:
    if len_==0:
        print(1)
    else:
        print(re*(2**temp))
```

    10
    ??????????
    test2 7893600
    252595200



```
410156250/(25**5)
# 410156250/252595200
# 4294967296
5*4*3*2
```




    120