## 题目 1669: 求圆的面积

时间限制: 1Sec 内存限制: 128MB 提交: 13903 解决: 6011

**题目描述**
```
题目很简单，已知半径r，求一个圆的面积是多大。

公式不用提了吧~~ 
```
**输入**

- 输入一个半径，浮点类型~

**输出**

- 输出它对应的面积大小，保留两位小数哦！

**样例输入**
```
2
```
**样例输出**
```
12.57
```


```
import math
PI=3.14159265358979323
r=float(input())
from decimal import *
a=PI*r*r
print ('%.7f'%a)
```

    2
    12.5663706
    


```
import math
math.pi
```




    3.141592653589793




```
a=int(input())

temp1=1
temp2=1
res=0
t=0
for i in range(3,a+1):
    res=(temp1+temp2)%10007
    temp1=temp2%10007
    temp2=res%10007
#     if res >10007:
#         print(res%10007)
#         t=1
#         break
if  a<=2:    #t==0 and
    print(1)
elif  a>2:    #t==0 and
    print(res%10007)
    
```

##  序列求和

**问题描述**
```
求1+2+3+…+n的值。
```
**输入格式**

- 输入包括一个整数n。

**输出格式**

- 输出一行，包括一个整数，表示1+2+3+…+n的值。

**样例输入**
```
4
```
**样例输出**
```
10
```
**样例输入**
```
100
```
**样例输出**
```
5050
```
**数据规模与约定**
```
1 <= n <= 1,000,000,000。
```


```
a=int(input())
res=0
for i in range(1,a+1):
    res+=i
print(int(((1+a)/2)*a))
```

## 题目 1853: [蓝桥杯][基础练习]数列排序

时间限制: 1Sec 内存限制: 128MB 提交: 982 解决: 628

**题目描述**

- 给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1<=n<=200

**输入**
```
第一行为一个整数n。
第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。
```
**输出**

- 输出一行，按从小到大的顺序输出排序后的数列。

**样例输入**
```
5
8 3 6 4 9

```
**样例输出**
```
3 4 6 8 9
```


```
a=int(input())
num=sorted(list(map(int,input().strip().split())))
for i in num:
    print(i,end=' ')
```

    5
    8 3 6 4 9
    3 4 6 8 9 


```
print('{:.1f}'.format(4.234324525254))
print('{:.4f}'.format(4.1))
```

##  进制转换

ASCII码转换为int：ord('A')    65

int转为ASCII码：chr(65)   'A'

在日常生活中我们频繁使用到数学的进制，如季度逢三进一，星期逢七进一；×××、小时使用12进制，每天使用24进制，每月使用30进制，分秒使用60进制，一年使用360进制等等；在编程过程中我们经常需要转换进制，虽然Python已经内置了常用进制转换函数，如int，bin，hex，oct；但是如果我们需要转换成其他进制怎么办呢？

    我们知道，十进制转换成二进制时，使用“除2取余，逆序排列”即可。二进制转换成十进制时按权展开，即可得到十进制。类似地可以实现十进制转换成任意进制，任意进制也可以转换成十进制；通过十进制进行中转，即可实现任意进制数之间的转换了。



```
#将十进制数转换成任意进制20进制以内，任意进制只需添加不同的符号即可
def decimalToAny(num,n):
    if num==0:
        return 0
    baseStr={}
    for i in range(10,n):
        baseStr[i]=chr(i-10+97)
    print(baseStr)
    new_num_str = ""
    while num != 0:
        remainder = num % n
        if  remainder > 9:
            remainder_string = baseStr[remainder]
        else:
            remainder_string = str(remainder)
        new_num_str = remainder_string+new_num_str
        num = num // n
    return new_num_str
decimalToAny(58,30)
```

    {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f', 16: 'g', 17: 'h', 18: 'i', 19: 'j', 20: 'k', 21: 'l', 22: 'm', 23: 'n', 24: 'o', 25: 'p', 26: 'q', 27: 'r', 28: 's', 29: 't'}
    




    '1s'




```
#将任意进制数转换成十进制
def anyToDecimal(num,n):
    baseStr={}
    for i in range(10):
        baseStr[str(i)]=i
    for i in range(10,n):
        baseStr[chr(i-10+97)]=i
    print(baseStr)
    new_num = 0
    for i in range(len(num)):
        new_num+=baseStr[num[len(num)-1-i]]*(n**i)
    return new_num
anyToDecimal('1s',30)
```

    {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15, 'g': 16, 'h': 17, 'i': 18, 'j': 19, 'k': 20, 'l': 21, 'm': 22, 'n': 23, 'o': 24, 'p': 25, 'q': 26, 'r': 27, 's': 28, 't': 29}
    




    58




```
print('{0}xxxxxxxx{1}'.format('这是0要传入的东西','这是1要传入的东西'))
```
test={'nan':'werty'}
print("ghjk{nan}gbhnjmk".format(**test))
test
进制转化，b o d x 分别表示二、八、十、十六进制


```
print('{:b}'.format(250))
print('{:o}'.format(250))
print('{:d}'.format(250))
print('{:x}'.format(250))
#千分位分隔符，这种情况只针对与数字
print('{:,}'.format(100000000))
print('{:,}'.format(235445.234235))
```

    11111010
    372
    250
    fa
    100,000,000
    235,445.234235
    

精度和类型f精度常和f一起使用


```
print('{:.1f}'.format(4.234324525254))
print('{:.4f}'.format(4.1))
```

    4.2
    4.1000
    

## 题目 2080: [蓝桥杯][基础练习]十六进制转八进制

时间限制: 1Sec 内存限制: 128MB 提交: 489 解决: 362

**题目描述**
```
给定n个十六进制正整数，输出它们对应的八进制数。
```
**输入**
```
输入的第一行为一个正整数n （1<=n<=10）。
接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。
```
**输出**
```
输出n行，每行为输入对应的八进制正整数。
```


**【注意】**
```
输入的十六进制数不会有前导0，比如012A。
输出的八进制数也不能有前导0。
```
**样例输入**
```
2
39
123ABC
```
**样例输出**
```
71
4435274
```


```

ord('A')
```




    65



### 方法1


```
n=int(input())
def f(num,n):
    baseStr={}
    for i in range(10,n):
        baseStr[i]=char(i-10+65)
    re=''
    while num!=0:
        temp=num%n
        if temp>9:
            re=baseStr[temp]+re
        else:
            re=str(temp)+re
        num//=n
    return re
for i in range(n):
    num=int(input(),16)
    print(f(num,8))
```

    1
    39
    71
    

### 方法2


```
n=int(input())
for i in range(n):
    temp=input()
    mid=int(temp,16)
    print('{:o}'.format(mid))
```

### 方法3


```
mapping= \
{
'0':"0000",
'1':"0001",
'2':"0010",
'3':"0011",
'4':"0100",
'5':"0101",
'6':"0110",
'7':"0111",
'8':"1000",
'9':"1001",
'A':"1010",
'B':"1011",
'C':"1100",
'D':"1101",
'E':"1110",
'F':"1111"
}

n=int(input())

for _ in range(n):
    n16=input()
    n2=''
    n8=''
    for i in n16:
        n2+=mapping[i]

    temp=len(n16)*4%3
    if temp==1:
        n2='00'+n2
    elif temp==2:
        n2='0'+n2

    flag=0
    for i in range(0,len(n2),3):
        num=4*int(n2[i])+2*int(n2[i+1])+int(n2[i+2])
        if num!=0:
            flag=1
        if flag:
            print(num,end='')

    print('')
```

    1
    39
    71
    
进行协议解析时，总是会遇到各种各样的数据转换的问题，从二进制到十进制，从字节串到整数等等
整数之间的进制转换:
10进制转16进制: hex(16)  ==>  0x10
16进制转10进制: int('0x10', 16)  ==>  16
类似的还有oct()， bin()
 

 
字符串转整数:
10进制字符串: int('10')  ==>  10
16进制字符串: int('10', 16)  ==>  16
16进制字符串: int('0x10', 16)  ==>  16
 


## 题目 2082: [蓝桥杯][基础练习]十六进制转十进制

时间限制: 1Sec 内存限制: 128MB 提交: 415 解决: 298

**题目描述**
```
从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。
注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。

```
**输入**
```
一个十六进制数

```
**输出**
```
对应得十进制
```
**样例输入**
```
FFFF
```
**样例输出**
```
65535
```


```
a=input()
print(int(a,16))
```

## 题目 2083: [蓝桥杯][基础练习]十进制转十六进制

时间限制: 1Sec 内存限制: 128MB 提交: 511 解决: 235

**题目描述**
```
十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。
给出一个非负整数，将它表示成十六进制的形式。
```
**输入**
```
输入包含一个非负整数a，表示要转换的数。0<=a<=2147483647
```
**输出**
```
输出这个整数的16进制表示
```
**样例输入**
```
30
```
**样例输出**
```
1E
```

### 法一


```
def f (num,n):
    baseStr={}
    for i in range(10,n):
        baseStr[i]=chr(i-10+65)
    re=''
    if num==0:
        return 0
    while num!=0:
        temp=num%n
        if temp>9:
            re=baseStr[temp]+re
        else:
            re=str(temp)+re
        num//=n
    return re
print(f(int(input()),16))
```

    30
    1E
    

### 法二


```
a=int(input())
print ('{:x}'.format(a).upper())
```

    30
    1E
    

## 题目 2084: [蓝桥杯][基础练习]特殊回文数

时间限制: 1Sec 内存限制: 128MB 提交: 663 解决: 312

**题目描述**
```
123321是一个非常特殊的数，它从左边读和从右边读是一样的。
输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。

```
**输入**
```
输入一行，包含一个正整数n。
```

**数据规模和约定**
```
1<=n<=54。
```
**输出**

- 按从小到大的顺序输出满足条件的整数，每个整数占一行。

**样例输入**
```
52
```
**样例输出**
```
899998
989989
998899
```


```
n=int(input())          
list_=[]
for i in range(1,10):
    for j in range(0,10):
        for k in range(0,10):
            if 2*(i+j+k)==n:
                list_.append(i*100000+i+j*10000+j*10+k*1000+k*100)
            if (2*i+2*j+k)==n:
                list_.append(i*10000+i+j*1000+j*10+k*100)
a=list(set(list_))
a.sort()
for i in range(len(a)):
    print(a[i])
```

## 回文数
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201218121659560.png)


```
for i in range(1,10):
    for j in range(10):
        print(i*1000+i+j*100+j*10)
```

## 特殊的数字
**资源限制**
时间限制：1.0s 内存限制：512.0MB

**问题描述**
- 153是一个非常特殊的数，它等于它的每位数字的立方和，即153=111+555+333。编程求所有满足这种条件的三位十进制数。

**输出格式**
- 按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。


```
for i in range(1,10):
    for j in range(10):
        for k in range(10):
            if (i*i*i+j*j*j+k*k*k)==(i*100+j*10+k):
                print(i*100+j*10+k)
```

## 杨辉三角形



```
n=int(input())
temp=[1]
for i in range(n):
    print(' '.join(list(map(str,temp))))
    n1=len(temp)
    t1=[1]
    j=0
    while j+1<n1:
        t1.append(temp[j]+temp[j+1])
        j+=1
        #print('t1',t1)
    temp=t1
    temp.append(1)
        
```

    4
    1
    1 1
    1 2 1
    1 3 3 1
    

## 题目 1231: 杨辉三角

时间限制: 1Sec 内存限制: 128MB 提交: 1796 解决: 633

**题目描述**
```
还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
```
**输入**

- 输入数据包含多个测试实例，每个测试实例的输入只包含一个正整数n（1＜=n＜=30），表示将要输出的杨辉三角的层数。

**输出**

- 对应于每一个输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开，每一个杨辉三角后面加一个空行。

**样例输入**
```
2 3
```
**样例输出**
```
1
1 1

1
1 1
1 2 1
```


```
num=map(int,input().strip().split())
for n in num:
#     n=int(input())
    temp=[1]
    for i in range(n):
        print(' '.join(list(map(str,temp))))
        n1=len(temp)
        t1=[1]
        j=0
        while j+1<n1:
            t1.append(temp[j]+temp[j+1])
            j+=1
            #print('t1',t1)
        temp=t1
        temp.append(1)
    print()
```

    2 3
    1
    1 1
    
    1
    1 1
    1 2 1
    
    

## 查找整数
 

时间限制：1.0s   内存限制：256.0MB

      

**问题描述**
```
给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。
```
**输入格式**
```

第一行包含一个整数n。

第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。

第三行包含一个整数a，为待查找的数。
```
**输出格式**
```
如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。
```
**样例输入**
```

6
1 9 4 8 3 9
9
```
**样例输出**
```

2
```

**数据规模与约定**

```
1 <= n <= 1000。
```


```
n=int(input())
list_=list(map(int,input().split()))
target=int(input())
true=0
for i in range(n):
    if list_[i]==target:
        print(i+1)
        true=1
        break
if true==0:
    print(-1)

```

## 数列特征 

时间限制：1.0s   内存限制：256.0MB

**问题描述**
```
给出n个数，找出这n个数的最大值，最小值，和。
```
**输入格式**
```
第一行为整数n，表示数的个数。

第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。
```
**输出格式**
```
输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。
```
**样例输入**
```
5
1 3 -2 4 5
```
**样例输出**
```
5
-2
11
```
**数据规模与约定**
```

1 <= n <= 10000。
```


```
n=int(input())
list_=list(map(int,input().split()))
print(max(list_))
print(min(list_))
print(sum(list_))
```

## 子母图形
**问题描述**
```
利用字母可以组成一些美丽的图形，下面给出了一个例子：

ABCDEFG

BABCDEF

CBABCDE

DCBABCD

EDCBABC

这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。
```
**输入格式**
```
输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。
```
**输出格式**
```
输出n行，每个m个字符，为你的图形。
```
**样例输入**
```
5 7
```
**样例输出**
```
ABCDEFG
BABCDEF
CBABCDE
DCBABCD
EDCBABC
```
**数据规模与约定**
```
1 <= n, m <= 26。
```


```
mn=list(map(int,input().split()))
q=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
]
t1=q[0:mn[1]]
print(''.join(t1))
#print('t1',t1[1],type(t1[1]))

for i in range(1,mn[0]):
    if i==1:
        print( ''.join(list(t1[1])+t1[0:-i]))
    else:
        t2[:]=reversed(t1[1:i+1])
        print(''.join(t2+t1[0:-i]))
```


```
mn=list(map(int,input().split()))
q=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
]
t1=q[0:mn[1]]
print(''.join(t1))
#print('t1',t1[1],type(t1[1]))
j=1
start=0
for i in range(1,mn[0]):
    if j==1:
        print( ''.join(list(t1[1])+t1[start:-j]))
    else:
        t2[:]=reversed(t1[start+1:j+1])
        print(''.join(t2+t1[start:-j]))
    j=j+1
    if j>=mn[0]:
        j=j-mn[0]
        start+=1
```

**上面的思路错了，下面的是对的**


```
def op1(mn,t1):
    print(''.join(t1[0:mn[1]]))
    #print('t1',t1[1],type(t1[1]))
    re=[]
    for i in range(1,mn[0]):
        if i==1:
            re=list(t1[1])+t1[0:-i]
            print(''.join(re[0:mn[1]]))
        else:
            t2=[]
            t2[:]=reversed(t1[1:i+1])
            re=t2+t1[0:-i]
            print(''.join(re[0:mn[1]]))


mn=list(map(int,input().split()))
q=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
op1(mn,q)

```

    20 20
    ABCDEFGHIJKLMNOPQRST
    BABCDEFGHIJKLMNOPQRS
    CBABCDEFGHIJKLMNOPQR
    DCBABCDEFGHIJKLMNOPQ
    EDCBABCDEFGHIJKLMNOP
    FEDCBABCDEFGHIJKLMNO
    GFEDCBABCDEFGHIJKLMN
    HGFEDCBABCDEFGHIJKLM
    IHGFEDCBABCDEFGHIJKL
    JIHGFEDCBABCDEFGHIJK
    KJIHGFEDCBABCDEFGHIJ
    LKJIHGFEDCBABCDEFGHI
    MLKJIHGFEDCBABCDEFGH
    NMLKJIHGFEDCBABCDEFG
    ONMLKJIHGFEDCBABCDEF
    PONMLKJIHGFEDCBABCDE
    QPONMLKJIHGFEDCBABCD
    RQPONMLKJIHGFEDCBABC
    SRQPONMLKJIHGFEDCBAB
    TSRQPONMLKJIHGFEDCBA
    


```
a=[1,2,3,3.3]
for i in a:
    print(i,end='')
```

    1122333.33.3


```
print(chr(65))
```

    A
    


```
m,n=map(int,input().split())
s=0
for i in range(m):
    k=65+i
    for j in range(n):
        print(chr(k), end='')
        if k==65:
            s=1
        if s==0:
            k=k-1
        else:
            k=k+1
    s=0
    print()
```

    20 20
    ABCDEFGHIJKLMNOPQRST
    BABCDEFGHIJKLMNOPQRS
    CBABCDEFGHIJKLMNOPQR
    DCBABCDEFGHIJKLMNOPQ
    EDCBABCDEFGHIJKLMNOP
    FEDCBABCDEFGHIJKLMNO
    GFEDCBABCDEFGHIJKLMN
    HGFEDCBABCDEFGHIJKLM
    IHGFEDCBABCDEFGHIJKL
    JIHGFEDCBABCDEFGHIJK
    KJIHGFEDCBABCDEFGHIJ
    LKJIHGFEDCBABCDEFGHI
    MLKJIHGFEDCBABCDEFGH
    NMLKJIHGFEDCBABCDEFG
    ONMLKJIHGFEDCBABCDEF
    PONMLKJIHGFEDCBABCDE
    QPONMLKJIHGFEDCBABCD
    RQPONMLKJIHGFEDCBABC
    SRQPONMLKJIHGFEDCBAB
    TSRQPONMLKJIHGFEDCBA
    


## 01字串

**问题描述**
```
对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：
00000
00001
00010
00011
00100
请按从小到大的顺序输出这32种01串。
```
**输入格式**

- 本试题没有输入。

**输出格式**

- 输出32行，按从小到大的顺序每行一个长度为5的01串。 

**样例输出**
```
00000
00001
00010
00011
<以下部分省略> 
```


```
for i in range(32):
    t1=i
    temp=[0]*5
    for j in range(5)[::-1]:
        if 2**j<=t1:
            temp[j]=1
            t1=t1-2**j
    print(''.join(map(str,reversed(temp))))
        
```

    00000
    00001
    00010
    00011
    00100
    00101
    00110
    00111
    01000
    01001
    01010
    01011
    01100
    01101
    01110
    01111
    10000
    10001
    10010
    10011
    10100
    10101
    10110
    10111
    11000
    11001
    11010
    11011
    11100
    11101
    11110
    11111
    

## 闰年判断


```
a=int(input())
if (a%4==0 and a//4!=0) and not(a%100==0and a//100!=0) or(a%400==0and a//400!=0):
    print('yes')
else:
    print('no')

```

    5
    no
    

## 题目 1039: [编程入门]宏定义之闰年判断

时间限制: 1Sec 内存限制: 128MB 提交: 6412 解决: 4348

**题目描述**
```
给年份year，定义一个宏，以判别该年份是否闰年。提示：宏名可以定义为LEAP_YEAR，形参为y，既定义宏的形式为 #define LEAP_YEAR(y) （读者设计的字符串）

```
**输入**

- 一个年份

**输出**

- 根据是否闰年输出，是输出"L",否输出"N"

**样例输入**
```
2000
```
**样例输出**
```
L
```


```
a=int(input())
if (a%4==0 and a//4!=0) and not(a%100==0and a//100!=0) or(a%400==0and a//400!=0):
    print('L')
else:
    print('N')
```

    2000
    L
    

## 题目 1474: [蓝桥杯][基础练习VIP]阶乘计算

时间限制: 1Sec 内存限制: 128MB 提交: 1948 解决: 858

**题目描述**
```
输入一个正整数n，输出n!的值。

其中n!=1*2*3*…*n。

算法描述

n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。

将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。

首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。

```
**输入**
```
输入包含一个正整数n，n< =1000。 

```
**输出**
```
输出n!的准确值。

```
**样例输入**
```
10 
```
**样例输出**
```
3628800
```


```
n=int(input())
res=1
for i in range(1,n+1):
    res*=i
print(res)
```

    10
    3628800
    


```
n=int(input())
def op (res,k):
    carry=0
    for i in range(len(res)):
        temp=res[i]*k+carry
        res[i]=temp%10
        carry=temp//10
    while carry!=0:
        res.append(carry%10)
        carry//=10
    return res
res=[1]
for i in range(1,n+1):
    res=op(res,i)
for i in res[::-1]:
    print(i,end='')
```

    10
    3628800


```
def op (k,res):
    n=len(res)
    temp=0
    for i in range(n):
        t=res[i]*k+temp
        res[i]=(t%10)
        temp=t//10
    while temp!=0:
        res.append(temp%10)
        temp=temp//10
    return res
n=int(input())
res=[1]
for i in range(1,n+1):
    res=op(i,res)
p=res[::-1]
print(''.join(map(str,p)))
```

    10
    3628800
    

## 题目 1475: [蓝桥杯][基础练习VIP]高精度加法

时间限制: 1Sec 内存限制: 128MB 提交: 2264 解决: 899

**题目描述**
```
输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。

算法描述

由于a和b都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。

定义一个数组A，A[0]用于存储a的个位，A[1]用于存储a的十位，依此类推。同样可以用一个数组B来存储b。

计算c  =  a  +  b的时候，首先将A[0]与B[0]相加，如果有进位产生，则把进位（即和的十位数）存入r，把和的个位数存入C[0]，即C[0]等于(A[0]+B[0])%10。然后计算A[1]与B[1]相加，这时还应将低位进上来的值r也加起来，即C[1]应该是A[1]、B[1]和r三个数的和．如果又有进位产生，则仍可将新的进位存入到r中，和的个位存到C[1]中。依此类推，即可求出C的所有位。

最后将C输出即可。
```
**输入**

- 输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。 

**输出**
- 输出一行，表示a  +  b的值。

**样例输入**
```
20100122201001221234567890
2010012220100122
```
**样例输出**
```
20100122203011233454668012
```


```
a=int(input())
b=int(input())
print(a+b)
```

    20100122201001221234567890
    2010012220100122
    20100122203011233454668012
    


```
a=list(map(int,list(input())))
b=list(map(int,list(input())))
a=a[::-1]
b=b[::-1]
a_point=0
b_point=0
carry=0
re=[]
while a_point<len(a) or b_point<len(b):
    if a_point<len(a):
        t1=a[a_point]
    else:
        t1=0
    if b_point<len(b):
        t2=b[b_point]
    else:
        t2=0
    t=t1+t2+carry
    re.append(t%10)
    carry=t//10
    a_point+=1
    b_point+=1
if carry !=0:
    re.append(1)
for i in re[::-1]:
    print(i,end='')
```

    20100122201001221234567890
    2010012220100122
    20100122203011233454668012

## 题目 1462: [蓝桥杯][基础练习VIP]Huffuman树

时间限制: 1Sec 内存限制: 128MB 提交: 1316 解决: 750

**题目描述**
```
Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。

给出一列数{pi}={p0,  p1,  …,  pn-1}，用这列数构造Huffman树的过程如下：

1.  找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa  +  pb。

2.  重复步骤1，直到{pi}中只剩下一个数。

在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。

本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。



例如，对于数列{pi}={5,  3,  8,  2,  9}，Huffman树的构造过程如下：

1.  找到{5,  3,  8,  2,  9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5,  8,  9,  5}，费用为5。

2.  找到{5,  8,  9,  5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8,  9,  10}，费用为10。

3.  找到{8,  9,  10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10,  17}，费用为17。

4.  找到{10,  17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。

5.  现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。

```
**输入**
```
输入的第一行包含一个正整数n（n< =100）。 

接下来是n个正整数，表示p0,  p1,  …,  pn-1，每个数不超过1000。 

```
**输出**
```
输出用这些数构造Huffman树的总费用。 

```
**样例输入**
```
5 
5 3 8 2 9
```
**样例输出**
```
59
```


```
n=int(input())
list_=list(map(int,input().split()))
res=[]
while len(list_)>1:
    a1=min(list_)
    list_.remove(a1)
    a2=min(list_)
    list_.remove(a2)
    list_.append(a1+a2)
    res.append(a1+a2)
print(sum(res))
```

    5
    5 3 8 2 9
    59
    

## 题目 1460: [蓝桥杯][基础练习VIP]2n皇后问题

时间限制: 1Sec 内存限制: 128MB 提交: 1133 解决: 557

**题目描述**
```
给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。
输入
输入的第一行为一个整数n，表示棋盘的大小。 

接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。
```
**输出**

- 输出一个整数，表示总共有多少种放法。 

**样例输入**
```
4
1 1 1 1 
1 1 1 1 
1 1 1 1 
1 1 1 1
```
**样例输出**
```
2
```


```

def m():
    n=int(input())
    nn=[]
    for i in range(n):
        nn.append(input().strip().split())
        res=[]
    def helper(row,temp,nn,cols,z,f):
        if row==n:
            res.append(temp)
            return 
        for col in range(n):
            if (col not in cols )and( (row+col)not in z) and ((row-col) not in f) and nn[row][col]=='1':
                helper(row+1,temp+[nn[row][:col]+['2']+nn[row][col+1:]],nn,cols|{col},z|{row+col},f|{row-col})
    helper(0,[],nn,set(),set(),set())
    re_=len(res)
    for i in range(len(res)):
        helper(0,[],res[i],set(),set(),set())
    return len(res)-re_
print(m())
```

    4
    1 1 1 1
    1 1 1 1
    1 1 1 1
    1 1 1 1
    2
    

### 小提示
- 对于n皇后问题，因为同一行、同一列或同一条对角线上都不能放置皇后，所以我们的思路是使用递归来遍历行，然后用for循环遍历列，同时建立列跟对角线的集合，只有不在集合中的位置才能放置皇后。
- 那么对于2n皇后问题我们就先对nn进行一次n皇后问题，接下来就在这个所有的放置完黑皇后的可能下来放置白皇后，等于是跑了两遍n皇后的算法来解决这个问题。



```
# n=int(input())
# nn=[]
# nn.append(list(map(int,input().split())))
def m():
    n=int(input())
    nn=[]
    for i in range(n):
        nn.append(list(input().split()))
    res=[[]]
    
    r=0
    def helper(i,temp,nn,col,z,f,l):
        if i==n:
#             print('t',temp)
#             print('r',l,res[l])
            res[l].append(temp)
            return 
    
        for j in range(n):
            if (j not in col)and ((i+j) not in z)and ((i-j) not in f )and nn[i][j]=='1':
                helper(i+1,temp+[list(''.join(nn[i][:j])+'2'+''.join(nn[i][j+1:]))],nn,col|{j},z|{i+j},f|{i-j},l)
    helper(0,[],nn,set(),set(),set(),0)
    #print('res',res)
    for k in range(len(res[0])):
        res.append([])
        helper(0,[],res[0][k],set(),set(),set(),k+1)
        #print(len(res[k+1]))
        r+=len(res[k+1])
    return r
print(m())

        
```

    4
    1 0 1 1 
    1 1 1 1
    1 1 1 1
    1 1 1 1
    0
    

## 题目 1468: [蓝桥杯][基础练习VIP]报时助手

时间限制: 1Sec 内存限制: 128MB 提交: 2238 解决: 867

**题目描述**
```
给定当前的时间，请用英文的读法将它读出来。

时间用时h和分m表示，在英文的读法中，读一个时间的方法是：

如果m为0，则将时读出来，然后加上“o'clock”，如3:00读作“three  o'clock”。

如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five  thirty”。

时和分的读法使用的是英文数字的读法，其中0~20读作：

0:zero,  1:  one,  2:two,  3:three,  4:four,  5:five,  6:six,  7:seven,  8:eight,  9:nine,  10:ten,  11:eleven,  12:twelve,  13:thirteen,  14:fourteen,  15:fifteen,  16:sixteen,  17:seventeen,  18:eighteen,  19:nineteen,  20:twenty。

30读作thirty，40读作forty，50读作fifty。

对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty  one”。

按上面的规则21:54读作“twenty  one  fifty  four”，9:07读作“nine  seven”，0:15读作“zero  fifteen”。
```
**输入**

- 输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。

**输出**

- 输出时间时刻的英文。

**样例输入**
```
0 15
```
**样例输出**
```
zero fifteen
```


```
h,m=input().split()
m=str(int(m))
h=str(int(h))
map_={'0':'zero', '1': 'one', '2':'two', '3':'three', '4':'four', '5':'five', '6':'six', '7':'seven', '8':'eight', '9':'nine', '10':'ten', '11':'eleven', '12':'twelve', '13':'thirteen', '14':'fourteen', '15':'fifteen', '16':'sixteen', '17':'seventeen', '18':'eighteen', '19':'nineteen', '20':'twenty'}
if int(h)<=20:
    str1=map_[h]
elif (int(h))>20 and int(h)<30:
    str1='twenty'+' '+map_[str(int(h)%10)]
if m=='0':
    str2='o\'clock'
elif (int(m))>20 and int(m)<30:
    str2='twenty'+' '+map_[str(int(m)%10)]
elif (int(m)//10)==3:
    str2='thirty'+' '+map_[str(int(m)%10)]
elif (int(m)//10)==4:
    str2='forty'+' '+map_[str(int(m)%10)]
elif (int(m)//10)==5:
    str2='fifty'+' '+map_[str(int(m)%10)]
else:
    str2=map_[m]
print(str1,end=' ')
print(str2,end='')
```

    20 21
    twenty twenty one

## 题目 1465: [蓝桥杯][基础练习VIP]回形取数

时间限制: 1Sec 内存限制: 128MB 提交: 1831 解决: 590

**题目描述**

- 回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。

**输入**

- 输入第一行是两个不超过200的正整数m,  n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。

**输出**

- 输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。

**样例输入**
```
3 3
1 2 3
4 5 6
7 8 9
```
**样例输出**
```
1 4 7 8 9 6 3 2 5
```

### 思路一


```
m,n=map(int,input().split())
nn=[]
for i in range(m):
    nn.append(input().split())
dir=[[1,0],[0,1],[-1,0],[0,-1]]
re=[]
x=0
y=0
state=0
n_left=0
m_left=0
m_right=m-1
n_right=n-1
while len(re)<m*n:
    re.append(nn[x][y])
    tx,ty=dir[state]
    if ((tx+x)>m_right):
        state=(state+1)%4
        n_left+=1
    elif((tx+x)<m_left):
        state=(state+1)%4
        n_right-=1
    elif((ty+y)>n_right):
        state=(state+1)%4
        m_right-=1
    elif ((ty+y)<n_left):
        state=(state+1)%4
        m_left+=1
    tx,ty=dir[state]
    x+=tx
    y+=ty
print(' '.join(re))
```

    3 3
    1 2 3
    4 5 6
    7 8 9
    1 4 7 8 9 6 3 2 5
    

### 思路二


```
def op(state_i,state_j,i,j):
    if state_i==1:
        i+=1
    elif state_i==2:
        i=i
    elif state_i==3:
        i-=1
    if state_j==1:
        j+=1
    elif state_j==2:
        j=j
    elif state_j==3:
        j-=1
    return [i,j]


dir
m,n=map(int ,input().split())
map_=[]
for i in range(m):
    map_.append(list(input().split()))



i=0
j=0
statei=[1,2,3,2]
statej=[2,1,2,3]
state_i=0
state_j=0
# label=0
while True :
    print(map_[i][j],end=' ')
    map_[i][j]='#'
    t1,t2=op(statei[state_i],statej[state_j],i,j)
    if t1==m or t2==n or map_[t1][t2]=='#':#(i==m-1 and (j==0 or j==n-1))or (j==n-1and(i==0 or i==m-1))
#         print(i,j)
        state_i=(state_i+1)%4
        state_j=(state_j+1)%4
        i,j=op(statei[state_i],statej[state_j],i,j)
        if i==m or j==n or map_[i][j]=='#' :#(i==m-1 and (j==0 or j==n-1))or (j==n-1and(i==0 or i==m-1))or
            break
        else :
            continue
    i,j=op(statei[state_i],statej[state_j],i,j)
        
```

    3 2
    1 2
    3 4
    5 6
    1 3 5 6 4 2 

## 题目 1476: [蓝桥杯][基础练习VIP]龟兔赛跑预测

时间限制: 1Sec 内存限制: 128MB 提交: 3055 解决: 818

**题目描述**
```
话说这个世界上有各种各样的兔子和乌龟，但是  研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔  子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以  上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。

然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1  米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找  到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。
```
**输入**

- 输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2< =100;t< =300;s< =10;l< =10000且为v1,v2的公倍数) 

**输出**

- 输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 

- 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 

**样例输入**
```
10 5 5 2 20
```
**样例输出**
```
D
4
```


```
# v1,v2,t,s,l=map(int ,input().split())

# l1=0
# l2=0
# l1time=0
# l2time=0
# while True:
#     dettime=(t-l1+l2)/(v1-v2)
#     #print('dettime',dettime)
#     detl1=dettime*v1
#     #print('detl1',detl1)
#     detl2=dettime*v2
#     #print('detl2',detl2)
#     if l1+detl1>=l or l2+detl2>=l:
#         l1time+=(l-l1)/v1
#         l2time+=(l-l2)/v2
#         if l1time>l2time:
#             print('T')
#             print(int(l2time))
#             print('l2',l2)
#             break
#         elif l1time==l2time:
#             print('D')
#             print(int(l1time))
#             break
#         else:
#             print('R')
#             print(int(l1time))
#             break
#     else:
#         l1+=detl1
#         if l2+detl2+s*v2>l:
#             print('T')
#             l2time+=dettime+(l-(l2+detl2))/v2
#             #print(int(l2time))
#         l2+=detl2+s*v2
#         l1time+=dettime+s
#         l2time+=dettime+s
        
```

    25 10 20 3 100
    dettime 1.3333333333333333
    detl1 33.33333333333333
    detl2 13.333333333333332
    dettime 2.0
    detl1 50.0
    detl2 20.0
    dettime 2.0
    detl1 50.0
    detl2 20.0
    R
    9
    


```
import math
v1,v2,t,s,l=map(int,input().split())
l1=0
l2=0
l1_time=0
l2_time=0
while True:
    if l1-l2>=t:
        l2+=v2*s
        l1_time+=s
        l2_time+=s
    dt1=l1_time+(l-l1)/v1
    dt2=l2_time+(l-l2)/v2
    l1+=v1
    l2+=v2
    l1_time+=1
    l2_time+=1
    if l1>=l or l2>=l:
        if dt1>dt2:
            print('T')
            print(math.ceil(dt2))
            break
        elif dt1==dt2:
            print('D')
            print(math.ceil(dt2))
            break
        else:
            print('R')
            print(math.ceil(dt1))
            break
```

    10 5 5 2 20
    D
    4
    


```
import math
v1,v2,t,s,l=map(int ,input().split())
l1=0
l2=0
l1time=0
l2time=0
while True:
    if l1-l2>=t:
        l2+=s*v2
        l1time+=s
        l2time+=s
    dt1=l1time+(l-l1)/v1
    dt2=l2time+(l-l2)/v2
    l1+=v1
    l2+=v2
    l1time+=1
    l2time+=1
    if l1>=l or l2>=l:
#         if l1>l2:
#             print('R')
#             print(l1time)
#             break
#         elif l1==l2:
#             print('D')
#             print(l1time)
#             break
#         else:
#             print('T')
#             print(l2time)
#             break
        if dt1>dt2:
            print('T')
            print(math.ceil(dt2))
            #print('l2',l2)
            break
        elif dt1==dt2:
            print('D')
            print(math.ceil(dt1))
            break
        else:
            print('R')
            print(math.ceil(dt1))
            break

```

    83 37 193 8 9213
    R
    247
    

## 题目 1473: [蓝桥杯][基础练习VIP]芯片测试

时间限制: 1Sec 内存限制: 128MB 提交: 981 解决: 503

**题目描述**
```
有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。

每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。

给出所有芯片的测试结果，问哪些芯片是好芯片。
```
**输入**
```
输入数据第一行为一个整数n，表示芯片个数。 

第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i,  j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本  身进行测试）。 
```

**输出**
```
按从小到大的顺序输出所有好芯片的编号 
```
**样例输入**
```
3 
1 0 1
0 1 0
1 0 1
```
**样例输出**
```
1 3
```


```
n=int(input())
map_=[]
dic={}
for i in range(n):
    temp=input().split()
    map_.append(temp)
    dic[tuple(temp)]=dic.get(tuple(temp),0)+1
a=max(dic,key=dic.get)
for i in range(n):
    if tuple(map_[i])==a:
        print(i+1,end=' ')

```

    3
    1 0 1
    0 1 0
    1 0 1
    1 3 


```
n=int(input())
map_=[]
dt={}
for i in range(n):
    temp=list(map(int ,input().split()))
    map_.append(temp)
    dt[tuple(temp)]=dt.get(tuple(temp),0)+1

a=max(dt,key=dt.get)
# b=max(dt.values())#,key=dt.values()
# print(b)
for i in range(n):
    if tuple(map_[i])==a:
        print(i+1,end=' ')
    
    
```

    3
    1 1 1
    1 1 1
    1 11 
    2
    1 2 

**python 字典获取最大和最小的value**


```
my_dict = {'x':500, 'y':5874, 'z': 560}  
  
key_max = max(my_dict.keys(), key=(lambda k: my_dict[k]))  
key_min = min(my_dict.keys(), key=(lambda k: my_dict[k]))  
  
print('Maximum Value: ',my_dict[key_max])  
print('Minimum Value: ',my_dict[key_min])
```

可以用max(dict,key=dict.get)方法获得字典dict中value的最大值所对应的键的方法，max(dict, key)方法首先遍历迭代器，并将返回值作为参数传递给key对应的函数，然后将函数的执行结果传给key，并以此时key值为标准进行大小判断，返回最大值

**sorted函数使用**


```
a=[1,2,3]
sorted(a)
```




    [1, 2, 3]




```
L=[('b',2),('a',1),('c',3),('d',4)]

sorted(L, key=lambda x:x[1]) 
```




    [('a', 1), ('b', 2), ('c', 3), ('d', 4)]




```
from operator import itemgetter, attrgetter
L=[('b',2,2),('a',1,1),('c',3,3),('d',4,4),('e',4,3)]
print(sorted(L, key=lambda x:(x[1],x[2]) )) 

```

    [('a', 1, 1), ('b', 2, 2), ('c', 3, 3), ('e', 4, 3), ('d', 4, 4)]
    


```
sorted(L, key=itemgetter(1,2)) 
```




    [('a', 1, 1), ('b', 2, 2), ('c', 3, 3), ('e', 4, 3), ('d', 4, 4)]




## 试题 基础练习 FJ的字符串

提交此题   
资源限制
时间限制：1.0s   内存限制：512.0MB

**问题描述**
```
　　FJ在沙盘上写了这样一些字符串：
　　A1 = “A”
　　A2 = “ABA”
　　A3 = “ABACABA”
　　A4 = “ABACABADABACABA”
　　… …
　　你能找出其中的规律并写所有的数列AN吗？
  ```
**输入格式**

- 仅有一个数：N ≤ 26。

**输出格式**

- 　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。

**样例输入**
```
3
```
**样例输出**
```
ABACABA
```


```
chr(65)
```




    'A'




```
N=int(input())
def op(n,s):
    if n==N+65-1:
        print (s+chr(n)+s)
        return
    op(n+1,s+chr(n)+s)
op(65,"")
```

    3
    ABACABA
    

## 题目 1463: [蓝桥杯][基础练习VIP]Sine之舞

时间限制: 1Sec 内存限制: 128MB 提交: 1605 解决: 964

**题目描述**
```
最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。
不妨设
An=sin(1–sin(2+sin(3–sin(4+...sin(n))...)
Sn=(...(A1+n)A2+n-1)A3+...+2)An+1
FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。
```
**输入**

- 仅有一个数：N<201。

**输出**

- 请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。

**样例输入**
```
3
```
**样例输出**
```
((sin(1)+3)sin(1-sin(2))+2)sin(1-sin(2+sin(3)))+1
```

### 思路一


```
N=int(input())
An=['']*N
An[0]='sin(1)'
sin='sin()'
for i in range(1,N):
    if i%2==0:
        An[i]=An[i-1][:-i]+'+'+sin[:-1]+str(i+1)+sin[-1:]+An[i-1][-i:]
    else:
        An[i]=An[i-1][:-i]+'-'+sin[:-1]+str(i+1)+sin[-1:]+An[i-1][-i:]
n=N
temp=An[0]+'+'+str(n)
n-=1
for i in range(1,N):
    temp="("+temp+")"+An[i]+'+'+str(n)
    n-=1
print(temp)
```

    3
    ((sin(1)+3)sin(1-sin(2))+2)sin(1-sin(2+sin(3)))+1
    

### 思路二


```
N=int(input())
sin='sin()'
An=['']*N
def op(N,s):
    if N==1:
        return sin[0:-1]+'1-'+s+sin[-1]
    if N%2==0:
        return op(N-1,sin[0:-1]+str(N)+'+'+s+sin[-1])
    else:
        return op(N-1,sin[0:-1]+str(N)+'-'+s+sin[-1])
# a=op(N-1,sin[0:-1]+str(N)+sin[-1])
#print(a)
An[0]='sin(1)'
for i in range(1,N):
    An[i]=op(i,sin[0:-1]+str(i+1)+sin[-1])
    #print(i+1,An[i])
n2=N
def op2(n,s,n2):
    if n==N-1:
        print(s+str(An[n])+'+'+str(n2))#+'+'+'str(1)
        return 
    op2(n+1,'('+s+An[n]+'+'+str(n2)+')',n2-1)
op2(0,'',n2)
```

    1
    sin(1)+1
    

## 题目 1469: [蓝桥杯][基础练习VIP]数的读法

时间限制: 1Sec 内存限制: 128MB 提交: 1037 解决: 350

**题目描述**
```
Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。

比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。

所以，他迫切地需要一个系统，然后当他输入12  3456  7009时，会给出相应的念法：

十二亿三千四百五十六万七千零九

用汉语拼音表示为

shi  er  yi  san  qian  si  bai  wu  shi  liu  wan  qi  qian  ling  jiu

这样他只需要照着念就可以了。

你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。

注意必须严格按照规范，比如说“10010”读作“yi  wan  ling  yi  shi”而不是“yi  wan  ling  shi”，“100000”读作“shi  wan”而不是“yi  shi  wan”，“2000”读作“er  qian”而不是“liang  qian”。
```
**输入**

- 有一个数字串，数值大小不超过2,000,000,000。

**输出**

- 是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。 

**样例输入**
```
1234567009 

```
**样例输出**
```
shi er yi san qian si bai wu shi liu wan qi qian ling jiu
```

### 思路一


```
import math
num=input().strip()
map1={'0':'ling','1':'yi','2':'er','3':'san','4':'si','5':'wu','6':'liu','7':'qi','8':'ba','9':'jiu'}
map2=[None,'shi','bai','qian']
num_lis=[]

'''
输入按照单位分开
'''
while num:
    if len(num)//4>0:
        num_lis.append(num[-4:])
        num=num[:-4]
#         print(num)
    else:
        num_lis.append(num)
        num=None
# print(num_lis)


'''
对每一个单位进行操作的操作函数
'''
def op(s):
    j=0
    res=[]
    for i in s[::-1]:
        if i=='0':
            if res and res[-1]=='ling':
                j+=1
                continue
            if not res:
                j+=1
                continue
            else:
                res.append(map1[i])
                j+=1
                continue
        else:
            res.append(map2[j])
            res.append(map1[i])
            j+=1
    if res and res[-1]=='yi' and res[-2]=='shi':
        del res[-1]
    return res[::-1]
# print(num_lis)


'''
输出结果
'''
re=[]
m=[None,'wan','yi','wanyi']
for i in range(len(num_lis))[::-1]:
    if op(num_lis[i]):
        re+=op(num_lis[i])
        re.append(m[i])
# print(re)
for i in re:
    if i :
        print(i,end=' ')
# print(' '.join(re))
        
        
        
```

    1234567009 
    ['7009', '3456', '12']
    shi er yi san qian si bai wu shi liu wan qi qian ling jiu 

### 思路二


```
s=input()
map_={'0':'ling','1':'yi','2':'er','3':'san','4':'si','5':'wu','6':'liu','7':'qi','8':'ba','9':'jiu'}
map2=['','shi','bai','qian']
s1=''
s2=''
s3=''
n=len(s)
nl=[0]*4
for i in range(4):
    if n<=0:
        break
    nl[i]=4 if n>=4 else n
    n-=4
s1=s[0:nl[3]]
s2=s[nl[3]:nl[3]+nl[2]]
s3=s[nl[3]+nl[2]:nl[2]+nl[1]+nl[3]]
s4=s[nl[2]+nl[1]+nl[3]:nl[2]+nl[1]+nl[3]+nl[0]]
res=[]



def op(s,res,map_,map2):
    j=0
    res=[]
#     print(s1,s2,s3)
    for i in s[::-1]: 
        if i=='0':
            
            if  res and res[-1]=='ling':
                j+=1
                continue
            if not res:
                j+=1
                continue 
            else:
                res.append(map_[i])
                j+=1
                continue
        res.append(map2[j])
        res.append(map_[i])
        j+=1
    if res and res[-1]=='yi' and res[-2]=='shi':
        del res[-1]
    return res





r4=op(s4,res,map_,map2)
res+=r4

if nl[1]>0:
    res.append('wan')
    r3=op(s3,res,map_,map2)
    if r3:
        res+=r3
    else:
        res.pop(-1)
    
    
if nl[2]>0:
    res.append('yi')
    r2=op(s2,res,map_,map2)
    if r2:
        res+=r2
    else:
        res.pop(-1)
    
    
if nl[3]>0:
    res.append('wan yi')
    r1=op(s1,res,map_,map2)
    if r1:
        res+=r1
    else:
        res.pop(-1)

res=reversed(res)
a=' '.join(res).split()
print(' '.join(a))
```

    2000000000000
    er wan yi
    

## 题目 1467: [蓝桥杯][基础练习VIP]完美的代价

时间限制: 1Sec 内存限制: 128MB 提交: 1659 解决: 536

**题目描述**
```
回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。

交换的定义是：交换两个相邻的字符

例如mamad

第一次交换  ad  :  mamda

第二次交换  md  :  madma

第三次交换  ma  :  madam  (回文！完美！)
```
**输入**
```
第一行是一个整数N，表示接下来的字符串的长度(N  < =  8000) 

第二行是一个字符串，长度为N.只包含小写字母 
输出
如果可能，输出最少的交换次数。 

否则输出Impossible 

```
**样例输入**
```
5 
mamad
```
**样例输出**
```
3
```

### 思路一


```
n=int(input())
l=list(input())

def find(target,l,n):
    i=n-1
    while i>=0:
        if target==l[i]:
            return i
        i-=1
def swap(i,j,l):
    if i<=j:
        temp=l[i]
        t=j-i
        for k in range(t):
            l[i+k]=l[i+k+1]
        l[j]=temp
    return l
k=0
res=0
label=0
while k<=(n//2-1):
    j=n-1-k
    if l[k]==l[j]:
        k+=1
    else:
        i=find(l[k],l[k:j+1],n-2*k)+k
        if i==k:
            if n%2==0:
                print('Impossible')
                label=1
                break
            else:
                l=swap(i,i+1,l)
                res+=1
        else:
            l=swap(i,j,l)
            res+=j-i
            k+=1

if label==0:
    print(res)   


```

    7847
    fdkzklcfzyuhivkbxnocsizsvkppdyuxaznbcxjmihvtrdpbepgjcffpkjwybhslljvwwvpzmvxxjozykikfwbrddjtbdebxvvttbnqaarmkvdvanbdhdchyilcmodoiiunqtikddvpmrkpiztampaagfukaslozztwsyteiiyksmwntlrxczldclgarwkaypxujkhtacmlnprmvkdvdbxsysoglpdrbmuhfceutkrxjhqrxfoaecdgdsalqrpxplvnctwamwaajfapqmezxikcyeegyocyiqiltmcdxpdfhjdbhnlivdwkygctihktsutwjplqhepzkrtolgtqmcmwvpbzlhvrwkztgtonhelqutjomhalxbrwzjqpsodzmjsalxvgxgdnutaseseqoysqzrgyetikmvzklphyfrrihugwnhuzidyaqpbodphhyjiecmryvtgyfsgnaxuvvtoamfuwrlzqkpevigdngbckrwvjvytebhmcvrovixxxtqalwliiapmwifezoperwwypwwghtuswkjvnotxegtqzpvfsauydgpklzotupvnhjcjyldjdgtbipzmnszkqpquvusvgdvfwptpzkisxkvhzposvvnxuhayphfplrdmouyvqmtvmrqxnwykrwxhnnnefmkituyttxeqhrjikemwqylveegrwlvlqdzdwuzjcmpveuscpbcnidfsxbluxxxaepjaqzsaiigzgpxiuyiognquvveszucyiuwpqesmhyfjorspusfvuqyenqlryragxnihdegqllgqoyfgwxaxegenleinvxkiftnkjiipdeqxlakjqufihkjxsupuvontntlsqiswrmovsipyulyqcsxnvjnaqttcblnkejdhjcibayfewgbiuekjlvdysnvolskbptfshwabpysqereamxtoydkrbswowuiyfwfvbfakkgtxnuqwmxwmatbnfchjaampuwmzcmoddmahtavzokckryrizzfxbobwnnzxvghcypcamxuhzbjynlzlkhzjdtgwbdajhxhajdxbedxkpqmbsfcaxtwsegabxvvadlerkbeqpyccrjewzkilrgyzdyiojjrsukewvtenrxzsdlpmbznmkbuotctowchgcwrwbqvfywdsebrjinhahgkasxbirdvilfdazgxlezknwjuhxkafntttljzzkubhgmtwqwokiatoqflpckkmkhfgrohhmalstdmyxuwnanhfbdgtrrsqxxqyctvnaykbzkirloozmhuvrvztdrvapcyubiwxnetdyzdbyihbhjqynumfdkwpzvcpupzouklvwsccgewnmorfiuqatnwmnaozdvzycpvxmrilgsykximfcitsnzsprzduxhwixagyfuecquctgzkopgaxmyvsfxyijfjjgzwhcdivrfmvtkubegkfbrynqxfvsvnzafclkfszwxlvcvikovwasqnixexilkpubsdsozccuoyxtpszkmsmuzmgttkkfhgsuaicsbhzpxzrneomnejqhkfmltwhkvmpefqzdtmadxgtscbdftrkjayulvhlpcprnxgryadrkwoarjgzuatkheuvtdtxiknsfqyuqhowbmnuysnamxenzauxgmlpaltffnaiadgqnpswecimeroavjdlryjtzgznhceqlengueuwdwegjxbjdspirxwegzzpuvujlugrlbfqmlifgsnedlsjrthcfedqpfzayviuigrgqjtqbcimxewmxnidjgjnqshubkwjilnhlaeeyysgxihknkdjoqtibhlfnkfsshgskxyptlnwyokvnruqrtkfliuaknhcmsqmaabvpskppbcwjtblwvfhyyquwkqnidonifgdtivsmcijpdxnsjytxtnmyxvzxrkkdqcusfgsrxwervarycsscpogymccfrjpctwdpcfkkfchiflzitbwazwurzryrmbyvsgnibmmldvrtjeywdydahixdntvfxxyqvhdsofxxbwqkggynybaaoqkyfafjipuqvexmshifjxjgznhpzwiytxkvofxidnfgvgnvpodpzvspntrrsdwhyhsucwjoenayigtmqiaxmlmamohmnrxjiomjvphxslfwrdmltvzrxnrvjlxuyubcwjulunfegfypwxcwpoduekwbjfhhwdijmymzhecummckwegggsjauahmocdwqzyzooylyutivttzebksukgmavbtsmlzujzdyeikabrqrixkismlxthotgkgaoxelhzqknmguwhuqzswalhprdbarubzsbsathyxpqrzihlkepgnnumbozxmbmagwjnvpiqhusbmemaivopofekcervnecptgqsyygxdaiqygvymbhralfqpyzbokmsmknxpibhekqmihvpgqxpmbktqiifcsugzldchfygpdysxmnhilvaaoarcwyxumrwotahailehxbyqgkkutflczojbzttwlgqbobizvsuzxiigzablwqxvvjvxenvuzfwlzijarcoywnuzejoihkerjoivvnaywpgvgmgcqfhexkonshgmgaemudywivlqghwswpjyvktdhnhigizzhiencsrehqvaznmvbvgzdesaeuetfykpmupvxcpbflhnipnhawxiikrrztznzewixwipfsmozbxyswsmymcpwckizzpbbyzamudnoxxhhfitrvzariqiltmhbpiostorafdxodmqseoiefzrmlxgbrniuuzexvhsbnybwrseygkogzghwoicblwsbdgcasydgxcxvptmtkixpwbdzfjhkeeevlqygdudcqxrivhejrctainfzjazvmfmelwulnaxbczealkqfiqwsfjhwprafxwmdrhbbourjpslwrjlhdsptzakqqcwsusgiozuuocftlsupxnetqhealgamhowyoabvacgjhezhrjpssmeyvhvslwzakahkeiloriihntexdphiurvcerwcwkftqwszmtmdwadjbcpxljduejbpazsgluoqnrcouomavbkxryzlvrhxmpstgdxbpsawipusnatocxsoqulkbxevqjbzwecymtydtjjypewmhhhmjpaihybuxiryuqgbjnyspammyzaefvlzmgvtqrvlvzhbxsesqbaghccfdtirwauvweymioyznrgpooqorcmwmzpkyfzgickjqtjwghwtpchudyscinfgjfkkzwlriopfhmjupnpktiakbkttwubfzrdfjdrqibfykggaraoqyswobpngmjjuywxrqpobckbpbtdzqdcgdyafkoflmjxhdljqvtvmdbiyoafmigwxhevfpxucnncwydaiqcnwjrgjxmckkuiaokysatipfylmvflaeqfhrgbhqdvinpbrfwyofmyggbicafcutzucqzxxlsoycvaklcubhbbxwzrhpodloejherwttletirwbsqvbexbvmoeucjogjamnczfaxatywoccklrlkiylgviqhnpqorhylkirlsuvdyqtbcgyqrxoiheicokbavpuwsahlankcggcrahqhvrilyphmtwlpwydfxzvahbbmmkmeigwrxcjomiabkacbxremziklosvbzivmqghrlvvnoarjyxgqsktjpqfvrgpelscokehfjqkrppiwjvygnohkzaqewkkicmplyxpboacgqzdlmtzkgslfcbfdjcrsgokqprdrvquyjpyubienziuldnkxcjciihyszzswkjojeegzgamuuzatubkvdjgurflccyxletmnpbwadsakhickjmvqovwrhmmkwrslbgxydazcpffysbavvieuqetcxipnksjahfzzkmnvahzxovgrcnbvtrdkppmevuscrwlkivmrckwmfsugpizyooqjmbnscraygtujpjjkisytxvqnqyuvqmbvsxdtlriwbrkcdjphgmfqbdisgckrvkxsjnaqeslahrjblequaukjqsbrpiziiqzpkuhjgerhdrirksbhhrvtklrnyykiomxqkpcelkphroqsuvkmivabfxpuahnpqzekwsnrkxqtzhyxfcqlkhudnqoplpcbcyfycmjrmrrbknmsgxckeedhwmmvyugkuqflmtdbhflaujjpnkteeuehxcduiknevguakcfdxubvbppygvanmjnjtmznxirgozwmatnebkseccjnnhoqqdezyygoncmbahbphczsdohgivbtcxdiiljcknizdrsicgrbsefpurbpxjtqnesuojdyvjujbxroxlsxszugihenfpsqlycnoworgrnyjzrknxwldsluuelfqdqsholeoocmvdauugrkdyawfugtmdtmmukvppjlonqidldwxbaeccoehzfyjdlwwzkucephrbahldykixpsskoayumirbxvfzouupznxkvcwdhmqqrfkjmjbyfhykrbirkhekuzlmimapqintpzvgnplovkkqkmzbtlcjiwtgqwvqhdsprxcsgawtovdrltjmyztxrtggcmrubdtltkvmgubsnrhaunvnawexaqytxxalpdconpjcmmeqrhdvwmviwjjizaqrvaftjvbskmtszgycqflgymeipkdsfguftmcbxspeorpnizxzrwszbatgyyygriwpjrpaqwcrykytihsmwaexuqqihxidqtyzalhkcwovezzjknnvhxeazehwoubvpivltgzphqisdlgkkqmegmuisyvjieakiproivnaeuynmjlxoypahxirmzvinpcxklhzhulktsnuhfinjnqozamcxgggjizvlimhupyywinbnockxtaxfmeukildeyqvfumnpdduujaaaxbdsatifqbqqtviimsmbyegsstkhcdtjtabdttbjvqynxzhnfelongxmofcenpnotfvnbmqyeeavqlmzqxnmgdikibxuwbuugtdikkxmcbhtgnlrzxmpskllrytywfveqbbbaauxyvljdyctkvngmkkvzzpnihsymwdlotwvxujmqaqskhabyjcdosdjgalqiplkvhxnazezjbwhymoincwnplbpsdadibmcyovihrpcmbhtwvceyxcousqikemnpioecwzbmmjdbxyaljsmkulvsvoozmujsloxlwsippcwlaoxdgjtyaiolkyniniiakpksqqziutheuqqblfiifccuxcqsxzqahfwyocvwlflwwiesqpkhleyfhjqsbmvwecuwdurnitvmrpohnmqbvmgcuutvdhqzcyibdzlzifxcxvgqtnevvtfktmmqpvvypliyesejxpivylunocnwufizulnwpqnmfavzgkufoxaierswyiiyzbolmqedcuihsywgcqkxaenaqljvrwnmuojckyifjwljzdzbzlgrjevgksaymfaaeahcrmibbszzoxgnwqfyfijrfurliizjtbijwgdskicqnmuhdzypxuvovzqchxrwihstgbviakungphxerhijjrhmhbdmsgwfyxjdhiaxkthgkatvlqegcovxilthhniboaqnwvizabxwlmhyaatqddfwdxfrsrzylimkaimqbikonagevxwiawjwywxziftbzxlxdezrldikqhyjdpyzqdlrrudcefjaswaohhvfasnkurcaxwoiurrgqzrxtrcfiuvitzoqpglmgbpmeekjbywcgzbrpglgujjhfrixloodpupuywaddmkrjkylxdanfjlpsuetrddqndqpfumfffxlzhttdklwktuwzktrmwtsfemhycbhhltyoiwlbroutrvtwktwghemivakwyzwgixvwhoqxuovxslkkhziievwwxafimdhtzccentfyyqbalinpxsryegitavfkgwvykhzcmtopovpzfezmllljqbwwgrvkjgywsisowhcgvsxwtgfvectfpodpptgsgvqwptprpmzdykyuzjxlnibmzzpjeawmgiamrvfqrgybvtlqxcwjmlcoaiflyllvluzzxtslaaxqexzdxdnvrcluspopxvxkycecmjlyfnvrwdwnkxnfmaqrlckuwzwgxkxsakqgfmgvhlwrtkustuwokizjksuogdqqwhyonkcwuquhidvaiepiravjjihbvlsujevpsawagecqvcollazzvthgxnrrozxorzjgjrqzblrfxzqndfavhjvaiftozcldlcxddtatatxndoboxlqcysmotxhxmcdtztgcvybdiusuebvuefozwzehnxzjbxjutwaabqxfuiomqznfysimtprihmbtajodsrntqvjgyubexnrhfgelhbrmexgwiuuuomxvamgadrrszdqghsntsfhsfgliuaqvemewxbsfcvmvviqejevkloomdbdjysawqpiorvzrhrgsnqoeamqnkttzynsrsfhkamdswmnfuytykrzkngcynlowepabfbfuptbyysafaeivimsksbwthkbfrxkhmvwspwyltjwmrsmdfmocsnszlacqheorueucwtwwthymjegpynwdumrztwpxhhsonodwszfzhqundwqdmqspfwwhgoodmgcwidgyzmjwjlostsxtrmukxcfsiudrmkmqigzpyiswiyveufyvvqufjxhalgdejwpmhswzchfbspkcoyrpttrxuwcebcjxogsqgesheujpcmeqfwpmrntkutsvpuwdsqpsxtwkzrwppmyatibvpgcvnjfyzlszyldesviqhetixjqisoclwrdmfxtwoddjegabhwnaexvpvpahvtkezjhxihnusccujsffzsansuiobrrezbtzpnhmzjwuszkpckejshhvyncwznklgklsmakmbkqwwcuejswasvtptlgnqzvyuftzvrldutawjyyhduwpliabwwpyxvqtrwuxvzgfubvpadpzppvnlzmqqtdekmzknmjglhgnpvifuvwrsbiudivzolvtqidhrklyyxcjhlsqcnxrbtikctwxmniknmlpttoormkwxmslrdpmucjxixnyfbaznzwtkhxhsiojwkdvgkmeeaoqatxtxtpbwllrwwgxnufvtjhmtkeaurmtqisniaiglxaerpxlkdwnqowkcpzycimnhxosoyfdadluuopqgwwmzshjfuiqwhtjaxeayhtlugvrclkfymjubuhsanfpwscyexyaxvxoxrurbsfrwxrliamdcwqqmivhafpxbvsvsopbprxfkrwaeatepgnvcxhmxbvjadmmnflmhmhypaznzptoewprirvxxciheutbttrxbhtcoyjlceidlylvrpzeitzkgnhopdgkdztjovsyntcxyjjcolcdpipoxnnbxdwppoyulptnblrarzvjosnximcsoobaioeitxxjlbnqsqvcxblwmuzynunoisylhaezvikfudtfdzilbmvrcwniphvauywdhytpvfbiqndwjowxfapauryferyixvvpnqnrclyxbwsljjeyszcnoaucyhunxkieghvmwhlhyhxowtmsfpuctpphkgxhsikqmehzivuqgzxsdysedxzkltdfqjdaadrvynpyhwaudezwvquinmpnkjvkwtlhkfkxiqllvtrxmjbrfbgvsuqihpwhwopmagizhuknlushnzgiknyublzpnajxcdchfkkodrgqfjlnjjeccdbbhfvalpwrckqntrankglwikiekqzfgweuukfriugiluwoeiwwjzgifmyuwzvyeqvovdynpfsmejzsttuvbtklzxynvauxsgbewrhrvipn
    460825
    

### 思路二


```



def main():
    def swap(point_left,point_right):
        temp=s[point_left]
        for i in range(point_left,point_right):
            s[i]=s[i+1]
        s[point_right]=temp
        return point_right-point_left
    
    
    n=int(input())
    s=list(input().strip())
#     print(s)
    i=0
    res=0
    while i<=(n//2-1):
        point_right=n-1-i
        if s[i]==s[point_right]:
            i+=1
        else:
            point_left=''.join(s[i:point_right+1]).rfind(s[i])+i
            if point_left==i:
                if n%2==0:
                    print('Impossible')
                    return 
                else:
                    res+=swap(point_left,point_left+1)
            else:
                res+=swap(point_left,point_right)
                i+=1
    print(res)
    return 
main()


```

    5
    mamad
    3
    

## 题目 2101: 矩阵面积相交

题目 2101: 矩阵面积相交

时间限制: 1Sec 内存限制: 128MB 提交: 20 解决: 9

**题目描述**

![image.png](attachment:image.png)





**输入**

输入包含多组测试数据，输入的第一行包含一个正整数 T，表示测试数据的组数。

接下来依次描述每组测试数据，对于每组测试数据:

第一行包含一个正整数 n，表示矩形的数量。
![image.png](attachment:image.png)


**输出**

对于每组测试数据，输出 n 行，其中第 i 行包含两个非负整数，用恰好一个空格隔开，这里第 i 行的第一个整数表示与输入给出的第 i个矩形严格有交集的矩

形数量（不含第 i 个矩形），第二个整数表示这些矩形分别与第 i 个矩形的交集面积之和。


**数据范围:**

T <= 10 ， 所有坐标均为不超过 5000 的非负整数。

**样例输入**

```
2
2
0 0 1 1
1 1 2 2
3
0 0 2 6
1 1 4 4
1 3 3 9
```
**样例输出**

```

0 0
0 0
2 6
2 5
2 5
```


```
def Area_cross(target,matrixs,target_index):
    count=0
    cross=0
    for i in range(len(matrixs)):
        if i!=target_index:
            xr=min(target[2],matrixs[i][2])
            xl=max(target[0],matrixs[i][0])
            y_up=min(target[3],matrixs[i][3])
            y_down=max(target[1],matrixs[i][1])
            if xr>xl and y_up>y_down:
                cross+=(xr-xl)*(y_up-y_down)
                count+=1
    return (count,cross)
            
    
            
n=int(input())
for i in range(n):
    n=int(input())
    matrixs=[]
    for j in range(n):
        matrixs.append(list(map(int,input().strip().split())))
    for k in range(n):
        target=matrixs[k]
        count,cross=Area_cross(target,matrixs,k)
        print(count,cross)
        
```

    1
    3
    0 0 2 6
    1 1 4 4 
    1 3 3 9
    2 6
    2 5
    2 5
    



## 试题 基础练习 矩形面积交

提交此题   
资源限制
时间限制：1.0s   内存限制：512.0MB

问题描述

   平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。

输入格式

   输入仅包含两行，每行描述一个矩形。
   
　　在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。

输出格式

　　输出仅包含一个实数，为交的面积，保留到小数后两位。

样例输入

```
1 1 3 3
2 2 4 4
```
样例输出

```
1.00
```


```
x1i=list(map(float,input().split()))
x2i=list(map(float,input().split()))
# if x1[2]<x1[0]:
#     x1[0],x1[2]=x1[2],x1[0]
#     x1[1],x1[3]=x1[3],x1[1]
# if x2[2]<x2[0]:
#     x2[0],x2[2]=x2[2],x2[0]
#     x2[1],x2[3]=x2[3],x2[1]
x1=[min(x1i[0],x1i[2]),min(x1i[1],x1i[3]),max(x1i[0],x1i[2]),max(x1i[1],x1i[3])]
x2=[min(x2i[0],x2i[2]),min(x2i[1],x2i[3]),max(x2i[0],x2i[2]),max(x2i[1],x2i[3])]
def s(x1,x2):
    x=abs(min(x1[2],x2[2])-max(x1[0],x2[0]))
    y=abs(min(x1[3],x2[3])-max(x1[1],x2[1]))
    res=float(x*y)
    if res>=0:
        print('{:.2f}'.format(res))
    else:
        print(1)
        print('{:.2f}'.format(0))
if (x1[0]>=x2[0]and x1[0]<=x2[2]and x1[1]>=x2[1]and x1[1]<=x2[3])or(x1[2]>=x2[0]and x1[2]<=x2[2]and x1[3]>=x2[1]and x1[3]<=x2[3]):
    print('zhen')
    s(x1,x2)
elif (x1[2]>=x2[0]and x1[2]<=x2[2]and x1[1]>=x2[1]and x1[1]<=x2[3])or (x1[0]>=x2[0]and x1[0]<=x2[2] and x1[3]>=x2[1]and x1[3]<=x2[3]):
    print('dao')
    s([x1[2],x1[1],x1[0],x1[3]],[x2[2],x2[1],x2[0],x2[3]])
else:
    print(2)
    print('{:.2f}'.format(0))
# else:
#     s([x1[0],x1[3],x1[2],x1[1]],[x2[0],x2[3],x2[2],x2[1]])
```

    283323.2393 2938832.3994 29838432.38288 983723.828
    27783.84384 8793002.2 3995852.3884 2928344.2
    dao
    312660026120.76
    

## 这道题刚开始思路错了下面是正确的


```
x1i=list(map(float,input().split()))
x2i=list(map(float,input().split()))
x1=[min(x1i[0],x1i[2]),min(x1i[1],x1i[3]),max(x1i[0],x1i[2]),max(x1i[1],x1i[3])]
x2=[min(x2i[0],x2i[2]),min(x2i[1],x2i[3]),max(x2i[0],x2i[2]),max(x2i[1],x2i[3])]
xl=max(x1[0],x2[0])
xr=min(x1[2],x2[2])
yup=min(x1[3],x2[3])
ydown=max(x1[1],x2[1])
x=xr-xl
y=yup-ydown
if xr>xl and yup>ydown:
    print('{:.2f}'.format(x*y))
else:
    print('{:.2f}'.format(0))
```

    1 1 4 5
    1 1 4 5
    12.00
    

## 题目 1472: [蓝桥杯][基础练习VIP]矩阵乘法

时间限制: 1Sec 内存限制: 128MB 提交: 1972 解决: 594

**题目描述**

```
给定一个N阶矩阵A，输出A的M次幂（M是非负整数）

例如：

A  =

1  2

3  4

A的2次幂

7  10

15  22
```
**输入**
```
第一行是一个正整数N、M（1< =N< =30,  0< =M< =5），表示矩阵A的阶数和要求的幂数 

接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值 
输出
输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开 
```

**样例输入**
```
2 2 
1 2 
3 4 
```
**样例输出**
```
7 10
15 22
```

### 思路一


```
N,M=map(int,input().strip().split())
A=[]
for i in range(N):
    A.append(list(map(int,input().split())))
def f(A,B,i,j,N):
    re=0
    for k in range(N):
        re+=A[i][k]*B[k][j]
    return re 
    
        
def op(A,M):
    temp=[[0]*N for i in range(N)]
    for i in range(N):
        for j in range(N):
            if i==j:
                temp[i][j]=1
    temp_next=[i.copy() for i in A]
    for i in range(M):
        for i in range(N):
            for j in range(N):
                temp_next[i][j]=f(temp,A,i,j,N)
        temp=[i.copy() for i in temp_next]
#         print(temp)
#         print()
    for i in temp:
        print(' '.join(list(map(str,i))))
    return temp 
op(A,M)
    
            
    
    
```

    2 2
    1 2
    3 4
    7 10
    15 22
    




    [[7, 10], [15, 22]]



### 思路二


```
N,M=map(int,input().split())
A=[]
for i in range(N):
    A.append(list(map(int ,input().split())))
def op(A,B,N):
    re=[[0]*N for _ in range(N)]
    for i in range(N):
#         temp=A[i]
        for j in range(N):
            for k in range(N):
                re[i][j]+=B[i][k]*A[k][j]
    return re
B=[[0 for j in range(len(A[0]))] for i in range(len(A))]
for i in range(N):
    B[i][i]=1
for i in range(M):
    B=op(A,B,N)
for i in range(N):
    print(' '.join(map(str,B[i])))
```

    2 2 
    1 2
    3 4
    7 10
    15 22
    

## 题目 1464: [蓝桥杯][基础练习VIP]分解质因数

时间限制: 1Sec 内存限制: 128MB 提交: 2156 解决: 1312

**题目描述**
```
求出区间[a,b]中所有整数的质因数分解。

提示


先筛出所有素数，然后再分解。

数据规模和约定

2< =a< =b< =10000

```



**输入**

- 输入两个整数a，b。

**输出**

- 每行输出一个数的分解，形如k=a1*a2*a3...(a1< =a2< =a3...，k也是从小到大的)(具体可看样例) 

**样例输入**
```
3 10
```
**样例输出**
```
3=3
4=2*2
5=5
6=2*3
7=7
8=2*2*2
9=3*3
10=2*5
```


```
a,b=map(int,input().split())
map_={1:'1',2:'2'}
def op(k,map_):
    for i in range(2,k):
        if k%i==0:
            map_[k]=map_[i]+'*'+map_[k//i]
#             print(k,map_[k])
            return
    map_[k]=str(k)
#     print(k,map_[k])
for i in range(1,b+1):
    op(i,map_)
# print(map_)
for i in range(a,b+1):
    print(str(i)+'='+map_[i])
    


```

    3 10
    3=3
    4=2*2
    5=5
    6=2*3
    7=7
    8=2*2*2
    9=3*3
    10=2*5
    


```
a,b=map(int,(input().split()))
map_={1:'1',2:'2'}
def op(k,map_):
    for i in range(2,k):
        if k%i==0:
            map_[k]=map_[i]+'*'+map_[k//i]
            return 
    map_[k]=str(k)
for i in range(1,b+1):
    op(i,map_)
for i in range(a,b+1):
    print(str(i)+'='+map_[i])
```

    3 10
    3=3
    4=2*2
    5=5
    6=2*3
    7=7
    8=2*2*2
    9=3*3
    10=2*5
    



## 题目 1466: [蓝桥杯][基础练习VIP]字符串对比

时间限制: 1Sec 内存限制: 512MB 提交: 4380 解决: 2608

**题目描述**
```
给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一：

1：两个字符串长度不等。比如  Beijing  和  Hebei

2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如  Beijing  和  Beijing

3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如  beijing  和  BEIjing

4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如  Beijing  和  Nanjing

编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。
```
**输入**

- 包括两行，每行都是一个字符串 

**输出**

- 仅有一个数字，表明这两个字符串的关系编号 

**样例输入**
```
BEIjing
beiJing
```
**样例输出**
```
3
```


```
'S'.lower()
```




    's'




```
str1=input()
str2=input()
def main(str1,str2):

    if len(str1)!=len(str2):
        print(1)
        return 
    elif str1==str2:
        print(2)
        return
    elif str1.lower()==str2.lower():
        print(3)
        return
    else:
        print(4)
        return 
main(str1,str2)
```

    MSN
    MQN
    4
    


```
s1=input()
s2=input()
if len(s1)!=len(s2):
    print(1)
elif s1==s2:
    print(2)
elif s1.lower()==s2.lower():
    print(3)
else:
    print(4)
```

    BEIjing
    beiJing
    3
    

## 题目 1470: [蓝桥杯][基础练习VIP]时间转换

时间限制: 1Sec 内存限制: 128MB 提交: 4205 解决: 2804

**题目描述**
```
给定一个以秒为单位的时间t，要求用  “< H> :< M> :< S> ”的格式来表示这个时间。< H> 表示时间，< M> 表示分钟，  而< S> 表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。
```
**输入**

- 输入只有一行，是一个整数t（0< =t< =86399）。 

**输出**

- 输出只有一行，是以“< H> :< M> :< S> ”的格式所表示的时间，不包括引号。 

**样例输入**
```
5436 
```
**样例输出**
```
1:30:36
```


```
H,M,S=0,0,0
time=int(input())
S=time%60
time=time//60
M=time%60
time=time//60
H=time%60
print(str(H)+':'+str(M)+':'+str(S))
```

    5436
    1:30:36
    


```
t=int(input())
s=t%60
t=t//60
m=t%60
t=t//60
h=t
print(str(h)+':'+str(m)+':'+str(s))
```

    5436
    1:30:36
    

## 只出现一次的数字||


```
def singleNumber( nums) -> int:
        one=0
        two=0
        three=0
        for num in nums:
            two|=one&num
            one=one^num
            three|=one&two
            print(three)
            print('{:b}'.format(three))
            one=one&~three
            two=two&~three
        return one
singleNumber([2,2,3,2])
```

    0
    0
    0
    0
    2
    10
    2
    10
    




    1




## 试题 算法训练 猴子吃包子

提交此题   
资源限制
时间限制：1.0s   内存限制：256.0MB

**问题描述**
```
　　从前，有一只吃包子很厉害的猴子，它可以吃无数个包子，但是，它吃不同的包子速度也不同；肉包每秒钟吃x个；韭菜包每秒钟吃y个；没有馅的包子每秒钟吃z个；现在有x1个肉包，y1个韭菜包，z1个没有馅的包子；问：猴子吃完这些包子要多久？结果保留p位小数。
  ```
**输入格式**

- 输入1行，包含7个整数，分别表示吃不同包子的速度和不同包子的个数和保留的位数。

**输出格式**

-　　输出一行，包含1个实数，表示吃完所有包子的时间。

**样例输入**
```
4 3 2 20 30 15 2

```
**样例输出**
```
22.50
```

**数据规模和约定**
```
　　0<x<100;0<y<100;0<z<100;0<x1<=1000000;0<y1<=10000000;0<z1<=10000000;0<p<=1000
  ```


```

```


```
x,y,z,x1,y1,z1,p=map(int,input().split())
t1=x1/x
t2=y1/y
t3=z1/z

#print('{:.pf}'.format(t1+t2+t3))
# print(round(t1+t2+t3,3))
# print(round(1.2222222222222,2))
re='%.{0}f'.format(p)
print(re%(t1+t2+t3))
```

    4 3 2 20 30 15 2
    22.50
    


```
p=2
a='%.{0}f'.format(p)
b='{2}{0}.{1}f{3}}'.format(':',p,'{','}')
print(b.format(t1+t2+t3))
print(a%(t1+t2+t3))
#print('%.{0}f'.format(p)%(t1+t2+t3)
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-212-8cb10b12506e> in <module>
          1 p=2
          2 a='%.{0}f'.format(p)
    ----> 3 b='{2}{0}.{1}f{3}}'.format(':',p,'{','}')
          4 print(b.format(t1+t2+t3))
          5 print(a%(t1+t2+t3))
    

    ValueError: Single '}' encountered in format string



```
chr(115)
```




    's'




## 试题 算法训练 Yaroslav and Algorithm

提交此题   
资源限制
时间限制：100ms   内存限制：128.0MB

**问题描述**
```
　　（这道题的数据和SPJ已完工，尽情来虐吧！）

　　Yaroslav喜欢算法。我们将描述一个他最喜欢的算法。

　　1.这个算法接受一个字符串作为输入。我们设这个输入字符串为a。
　　2.这个算法由一些命令组成。i号命令的形式为"s[i]>>w[i]"或"s[i]<>w[i]"，其中s[i]和w[i]是长度不超过7的字符串（可以为空），由数字或字符"?"组成。
　　3.这个算法每次寻找一个编号最小的命令i，使得s[i]是a的子串。如果没有找到这样的命令，那么整个算法终止。
　　4.设找到的命令编号为k。在字符串a中，s[k]第一次出现的位置会被w[k]替换。如果这个命令形如"s[k]>>w[k]"，那么这个算法继续执行（译注：回到第3步）。否则，算法终止。
　　5.算法的输出就是算法终止时字符串a的值。

　　Yaroslav有一个n个正整数的集合，他需要一个这样的算法，且能够使每一个数加1。更正式地，如果我们把每个数看成一个十进制表示的字符串，那么对于每个字符串独立地运行这个算法，这个算法需要输出一个输入串对应的数+1的字符串。
　　帮帮他吧！

```
**输入格式**

　　- 第一行包含一个整数n（集合中数的个数），接下来n行，每行包含一个正整数。
  
**输出格式**
```
　　输出一个符合题意的算法（能够分别将每个数增加1）。第i行输出这个算法的第i个命令，不包含空格。
　　你的算法将会对于每个输入运行一遍。你的输出会被认为是正确的，当且仅当：
　　·每行都是一个合法的命令（格式见题目描述）
　　·命令的条数不能超过50。
　　·算法需要对每个给出的数+1。
　　·为了得到结果，算法必须对于每个输入都执行不超过200步。
```
**样例输入**
```
2
10
79
```
**样例输出**
```
10<>11
79<>80

```
**数据规模和约定**

　　1≤每个数≤10^25。共有20个测试点，对于第i个测试点，n=5i。



```
n=int(input())
for i in range(n):
    temp=int(input())
    print(str(temp)+'<>'+str(temp+1))
```

    2
    10
    10<>11
    79
    79<>80
    


## 试题 算法训练 Sereja and Squares

提交此题   
资源限制
时间限制：4.0s   内存限制：256.0MB

**问题描述**
```
　　Sereja在平面上画了n个点，点i在坐标(i,0)。然后，Sereja给每个点标上了一个小写或大写英文字母。Sereja不喜欢字母"x"，所以他不用它标记点。Sereja认为这些点是漂亮的，当且仅当：
　　·所有的点可以被分成若干对，使得每个点恰好属于一一对之中。
　　·在每对点中，横坐标较小的会被标上小写字母，较大的会被标上对应的大写字母。
　　·如果我们在每对点上画一个正方形，其中已知的一对点会作为正方形的相对的顶点，它们间的线段会成为正方形的对角线，那么在所有画出的正方形中不会有相交或触碰的情况。
　　小Petya擦掉了一些小写字母和所有大写字母，现在Sereja想知道有多少种方法来还原每个点上的字母，使得还原后这些点是漂亮的。
  ```
**输入格式**
```
　　第一行是一个整数n，表示点的个数。
　　第二行是一个长度为n的字符串，包含小写字母和问号"?"，是按照横坐标递增的顺序的每个点的描述。问号表示这个点的字母被Petya擦掉了。保证输入串不含字母"x"。
```
**输出格式**
```
  输出答案对4294967296取模的值。如果没有可行的方案，输出0。
```

**样例输入**

```
4
a???
```

**样例输出**

```
50
```

**样例输入**

```
4
abc?
```

**样例输出**

```
0
```

**样例输入**

```
6
abc???

```

**样例输出**

```
1

```

**数据规模和约定**

```
　　20个测试点的n分别为：
　　5,10,20,50,100,
　　200,500,1000,2000,5000,
　　10000,20000,30000,40000,50000,
　　60000,70000,80000,90000,100000.
```


```
# print('a'>'b')
# print(ord('a'))
# print(ord('A'))
# print(ord('a')-ord('A'))
# print(ord('b')-ord('B'))
n=int(input())
s=list(input())
len_=0
re=1
label=0
temp2=26
for j in s:
    if j=='?':
        len_+=1
for i in range(n):
    if s[i]>='a'and s[i]<='z':
        temp2-=1
        if chr(ord(s[i])+32)in s[i:]:
            s.remove(chr(ord(s[i])+32))
        else:
            if len_<=0:
                label=1
                break
#             re*=len_
            len_-=1
#             print(re,len_)
            
# print('test1',re)
if len_%2!=0:
    label=1
else:
    temp=len_//2
    for i in range(temp):
        re*=temp2
        temp2-=1
#         temp-=1
print('test2',re)
if label ==1:
    print(0)
else:
    if len_==0:
        print(1)
    else:
        print(re*(2**temp))
```

    10
    ??????????
    test2 7893600
    252595200
    


```
410156250/(25**5)
# 410156250/252595200
# 4294967296
5*4*3*2
```




    120



## 上面这道题没做出来，没理解题目的意思


```
n=int(input())
s=list(input())
dp=[[0for i in range(n)] for j in range(2)]
m=0
n2=n//2
now=0
dp[0][0]=1
for i in range(n):
    if s[i]=='?':
        now^=1
        for j in range((i+1)//2+1):
            #print(now,j)
            dp[now][j]=dp[now^1][j]+dp[now^1][j-1]
        #print(dp[now])
    else:
        m+=1
if (n2<m or n%2!=0):
    print(0)
else :
    for i in range(n2-m):
        dp[now][n2]*=25
        dp[now][n2]=dp[now][n2]%4294967296
    print(dp[now][n2])
```

    10
    ??????????
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    [1, 2, 0, 0, 0, 0, 0, 0, 0, 0]
    [1, 3, 2, 0, 0, 0, 0, 0, 0, 0]
    [1, 4, 5, 0, 0, 0, 0, 0, 0, 0]
    [1, 5, 9, 5, 0, 0, 0, 0, 0, 0]
    [1, 6, 14, 14, 0, 0, 0, 0, 0, 0]
    [1, 7, 20, 28, 14, 0, 0, 0, 0, 0]
    [1, 8, 27, 48, 42, 0, 0, 0, 0, 0]
    [1, 9, 35, 75, 90, 42, 0, 0, 0, 0]
    410156250
    


```
n=int(input())
s=list(input())
#dp=[[0]*n for i in range(n)]
f=[0]*n
f[0]=1
m=0
n2=n//2   #n>>1
#print (n2)
for i in range(n):
    if s[i]=='?':
        j=(i+1)//2  #(i+1)>>1
        while j>=1:#max(1,(i+1)-n2)
            f[j]+=f[j-1]
            j-=1
        print(f)
    else:
        m+=1
print(f)
if (n2<m or n%2!=0):
    print(0)
else:
    i=n2-m
    while i>0:
        f[n2]*=25
        f[n2]= f[n2]%4294967296
        i-=1
    print(f[n2])
```

    10
    ??????????
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    [1, 2, 0, 0, 0, 0, 0, 0, 0, 0]
    [1, 3, 2, 0, 0, 0, 0, 0, 0, 0]
    [1, 4, 5, 0, 0, 0, 0, 0, 0, 0]
    [1, 5, 9, 5, 0, 0, 0, 0, 0, 0]
    [1, 6, 14, 14, 0, 0, 0, 0, 0, 0]
    [1, 7, 20, 28, 14, 0, 0, 0, 0, 0]
    [1, 8, 27, 48, 42, 0, 0, 0, 0, 0]
    [1, 9, 35, 75, 90, 42, 0, 0, 0, 0]
    [1, 9, 35, 75, 90, 42, 0, 0, 0, 0]
    410156250
    


```
1855780572/16796
```




    110489.4362943558



## 试题 算法训练 Rotatable Number


```

```

## 试题 算法训练 Playing with String


```
s=list(input())
n=len(s)
index=[]
i=0
while i<n:
    c=i
    j=0
    while c-j-1>=0 and c+j+1<n and  s[c-j-1]==s[c+j+1]:
        j+=1
    if j>=1:
        index.append(i+1)
        i+=1
    else:
        i+=1
print(index)
if len(index)%2==0:
    print('Second')
else:
    print('First')
    print(index[0])
    
```

    ccccccc
    [2, 3, 4, 5, 6]
    First
    2
    


```
a=(6**7)/2
print(a)
print(12.5*1024)
```

    139968.0
    12800.0
    


```

```


## 模拟题1
**问题描述**
```
　　将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。
　　请问，总共能排列如多少个不同的单词。
答案提交
　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
  ```


```
res=1
for i in range(1,8):
    res*=i
print(res/2)
```

## 模拟题2
问题描述
```
　　给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。
　　请问在 1 至 n 中有多少个反倍数。
```
**输入格式**
```
　　输入的第一行包含一个整数 n。
　　第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。

```
**输出格式**
　　- 输出一行包含一个整数，表示答案。
  
**样例输入**
```
30
2 3 6
```
**样例输出**

- 10

**样例说明**
```
以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。
评测用例规模与约定
　　对于 40% 的评测用例，1 <= n <= 10000。
　　对于 80% 的评测用例，1 <= n <= 100000。
　　对于所有评测用例，1 <= n <= 1000000，1 <= a <= n，1 <= b <= n，1 <= c <= n。
```


```
n=int(input())
a,b,c=map(int,input().split())
res=0
for i in range(1,n+1):
    if i%a!=0and i%b!=0 and i%c!=0:
#         print(i)
        res+=1
print(res)
```

    30
    2 3 6
    1
    5
    7
    11
    13
    17
    19
    23
    25
    29
    10
    

## 模拟题3
**问题描述**
```
　　给定一个单词，请使用凯撒密码将这个单词加密。
　　凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，...，w变为z，x变为a，y变为b，z变为c。
　　例如，lanqiao会变成odqtldr。
```

**输入格式**

输入一行，包含一个单词，单词中只包含小写英文字母。

**输出格式**

输出一行，表示加密后的密文。

**样例输入**

lanqiao

**样例输出**

odqtldr

**评测用例规模与约定**
　　对于所有评测用例，单词中的字母个数不超过100。


```
# ord('a')
s=input()
res=''
for i in s:
    temp=chr((ord(i)-97+3)%26+97)
    res+=temp
print(res)
```

    lanqiao
    odqtldr
    

## 模拟题4
**问题描述**
```
　　对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。
　　例如，一个 4 行 5 列的螺旋矩阵如下：
　　1 2 3 4 5
　　14 15 16 17 6
　　13 20 19 18 7
　　12 11 10 9 8
```
**输入格式**
```
　　输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。
　　第二行包含两个整数 r, c，表示要求的行号和列号。
```
**输出格式**
```
　　输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。

```
**样例输入**
```
4 5
2 2
```
**样例输出**
```
15
```
**评测用例规模与约定**
```
　　对于 30% 的评测用例，2 <= n, m <= 20。
　　对于 70% 的评测用例，2 <= n, m <= 100。
　　对于所有评测用例，2 <= n, m <= 1000，1 <= r <= n，1 <= c <= m。
  ```


```
a,b=[1,2]
print(a)
```

    1
    


```
n,m=map(int,input().split())
r,c=map(int,input().split())
nn=[[0]*m  for i in range(n)]
i=0
j=0
num=1
n_status=['=','+','=','-']
m_status=['+','=','-','=']
n_s=0
m_s=0
def op1(n_status,m_status,n_s,m_s,i,j):
    if n_status[n_s]=='+':
        i+=1
    elif n_status[n_s]=='-':
        i-=1
    if m_status[m_s]=='+':
        j+=1
    elif m_status[m_s]=='-':
        j-=1
    return [i,j]
def op2(n_status,m_status,n_s,m_s,i,j):
    if n_status[n_s]=='+':
        i-=1
    elif n_status[n_s]=='-':
        i+=1
    if m_status[m_s]=='+':
        j-=1
    elif m_status[m_s]=='-':
        j+=1
    return [i,j]
while True :
    if (i+1)==r and (j+1)==c:
        print(num)
        break
    if i<n and j<m and nn[i][j]==0:
        nn[i][j]=num
    else:
        i,j=op2(n_status,m_status,n_s,m_s,i,j)
        num-=1
        n_s=(n_s+1)%4
        m_s=(m_s+1)%4
#     if n_status[n_s]=='+':
#         i+=1
#     elif n_status[n_s]=='-':
#         i-=1
#     if m_status[m_s]=='+':
#         j+=1
#     elif m_status[m_s]=='-':
#         j-=1
    i,j=op1(n_status,m_status,n_s,m_s,i,j)
    num+=1
# print(nn)
```

    4 5
    2 2
    15
    


## 模拟题5
**问题描述**
```
　　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]<a[2i-1], a[2i+1]>a[2i]。
　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。
  ```
**输入格式**

　　输入一行包含两个整数 m，n。

**输出格式**

输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。

**样例输入**

3 4

**样例输出**

14

**样例说明**

```
　　以下是符合要求的摆动序列：
　　2 1 2
　　2 1 3
　　2 1 4
　　3 1 2
　　3 1 3
　　3 1 4
　　3 2 3
　　3 2 4
　　4 1 2
　　4 1 3
　　4 1 4
　　4 2 3
　　4 2 4
　　4 3 4
  ```
**评测用例规模与约定**
```
　　对于 20% 的评测用例，1 <= n, m <= 5；
　　对于 50% 的评测用例，1 <= n, m <= 10；
　　对于 80% 的评测用例，1 <= n, m <= 100；
　　对于所有评测用例，1 <= n, m <= 1000。
  ```


```
a=[1,2]+[3]
print(a)
```

    [1, 2, 3]
    


```
m,n=map(int,input().split())
res=[]
for k in range(1,n+1):
    res.append([k])
while len(res[0])<m:
    temp=[]
    for i in range(len(res)):
        if (len(res[i])+1)%2==0:
            for j in range(1,res[i][-1]):
                temp.append(res[i]+[j])
        else:
            for j in range(res[i][-1]+1,n+1):
                temp.append(res[i]+[j])
    res=temp
print(len(res))
```

    3 4
    14
    

## 模拟题6
**问题描述**
```
　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。
　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。
　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。
　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。
　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。
  ```
**输入格式**
```
　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。
　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。
```
**输出格式**
```
　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。

```
**样例输入**
```
6
1 1 2
1 4 2
1 7 2
4 1 2
4 4 2
4 7 2
```
**样例输出**
```
12
```

**评测用例规模与约定**

```
　　对于 30% 的评测用例，1 <= n <= 10；
　　对于 60% 的评测用例，1 <= n <= 20；
　　对于所有评测用例，1 <= n <= 30，0 <= x, y <= 1000，1 <= r <= 1000。
请选择编程语言 
```

1







```
import math
n=int(input())
x=[0]*n
y=[0]*n
r=[0]*n
s=[0]*n
map_=[]
for i in range(n):
    x[i],y[i],r[i]=map(int,input().split())
    s[i]=r[i]*r[i]   #math.pi*
    map_.append([x[i],y[i],r[i],s[i]])
sorted(map_, key=lambda x:(x[-1])) 
i=2
s_res=map_[-1][-1]
temp=[map_[-1]]
while i<=n:
    label=1
    for j in range(len(temp)):
        if (temp[j][0]-map_[-i][0])**2+(temp[j][1]-map_[-i][1])**2<(temp[j][2]+map_[-i][3])**2:
            label=0
    if label==1:
        print(map_[-i])
        temp.append(map_[-i])
        s_res+=map_[-i][-1]
    i+=1
    
print(s_res)
```

    6
    1 1 2
    1 4 2
    1 7 2
    4 1 2
    4 4 2
    4 7 2
    [4, 1, 2, 4]
    8
    


```
print(temp)
a=100
def b():
    print(a)
b()
```

    [[4, 7, 2, 4], [4, 1, 2, 4]]
    100
    


```
import math
n=int(input())
x=[0]*n
y=[0]*n
r=[0]*n
# s=[0]*n
# map_=[]
for i in range(n):
    x[i],y[i],r[i]=map(int,input().split())
    #s[i]=r[i]*r[i]   #math.pi*
global ans
ans=0
vis=[False]*n
def cal(i):
    for j in range(n):
        if i!=j and vis[j]:
            dis=(x[i]-x[j])**2+(y[i]-y[j])**2
            if dis<(r[i]+r[j])**2:
                return False
    return True
def dfs(step,sum_):
    if step==n:
        global ans
        t=max(ans,sum_)
#         print(sum_)
        ans=t
        return 
    for i in range(n):
        if not vis[i]:
            temp=r[i]
            if not cal(i):
                r[i]=0
            vis[i]=True
            dfs(step+1,sum_+r[i]*r[i])
            vis[i]=False
            r[i]=temp
dfs(0,0)
print(ans)
```

    6
    1 1 2
    1 4 2
    1 7 2
    4 1 2
    4 4 2
    4 7 2
    12
    
问题描述
　　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。
　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。
　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。
　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为
　　sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。
　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。
　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。
输入格式
　　输入的第一行包含一个整数 n ，表示村庄的数量。
　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。
输出格式
　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。
样例输入
4
1 1 3
9 9 7
8 8 6
4 5 4
样例输出
17.41
评测用例规模与约定
　　对于 30% 的评测用例，1 <= n <= 10；
　　对于 60% 的评测用例，1 <= n <= 100；
　　对于所有评测用例，1 <= n <= 1000，0 <= x, y, h <= 10000。

```
res=1
for i in range(1,8):
    res*=i
print(res/2)
```

    2520.0
    


```
r=1
for i in range(5):
    r*=0.8
print(r)
```

    0.32768000000000014
    


```
for i in range(5,-1,-1):
    print(i)
```

    5
    4
    3
    2
    1
    0
    

## 格雷编码


```
def grayCode( n: int):
        num = "0" * n
        res = [0]
        c = 2 ** n
        while len(res) < c:
            if num[-1] == "0":
                num = num[:-1] + "1"
                res.append(int(num, 2))
            else:
                num = num[:-1] + "0"
                res.append(int(num, 2))
            print(num)

            if len(res) == c:
                break
            idx = num.rfind("1")
            if num[idx - 1] == "0":
                num = num[:idx - 1] + "1" + num[idx:]
            else:
                num = num[:idx - 1] + "0" + num[idx:]
            print(num)
            res.append(int(num, 2))

        return res
grayCode(4)
```

    0001
    0011
    0010
    0110
    0111
    0101
    0100
    1100
    1101
    1111
    1110
    1010
    1011
    1001
    1000
    




    [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8]




```
a=[1,2,1,3]

# a=sorted(a,reverse=True)
# a.index(1)
a.sort(reverse=True)
a
```




    [3, 2, 1, 1]




```

```


```

```


```
'NUM 1024'.split()
```




    ['NUM', '1024']




```
'ADD'.split()
```




    ['ADD']




```
def change(num,k):
    
n=int(input())
num=''
for i in range(n):
    temp=input().split()
    
```

    5
    




    int




```
n=int(input())
num=list(map(int ,input().strip().split()))
re=0
for i in range(n-1):
    index=num.index(min(num))
    re+=num[index]*num[index-1]*num[(index+1)%(n-i)]
    del num[index]
print(re)
```

    4 
    2 3 5 10
    710
    

## 题目 1255: [蓝桥杯][算法提高]能量项链

时间限制: 1Sec 内存限制: 128MB 提交: 2168 解决: 704

**题目描述**

在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有 N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标 记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗 能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m， 尾标记为n。
需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

**例如：**

设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号◎表示两颗珠子的聚合操作，(j◎k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：
(4◎1)=10*2*3=60。
这一串项链可以得到最优值的一个聚合顺序所释放的总能量为
((4◎1)◎2)◎3）=10*2*3+10*3*5+10*5*10=710。

**输入**

第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行 是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i〈N时，第i颗珠子的尾标记应该等于第i+1颗 珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。
至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

**输出**

只有一行，是一个正整数E（E≤2.1*10^9），为一个最优聚合顺序所释放的总能量

**样例输入**

```python
4
2 3 5 10
```

**样例输出**

```python
710
```



```
n=int(input())
num=list(map(int ,input().strip().split()))
re=0
for i in range(n-1):
    index=num.index(min(num))
    re+=num[index]*num[index-1]*num[(index+1)%(n-i)]
    del num[index]
print(re)
```

## 题目 1004: [递归]母牛的故事

时间限制: 1Sec 内存限制: 128MB 提交: 50680 解决: 15534

**题目描述**
有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？

**输入**

> 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0<n<55)，n的含义如题目中描述。 n=0表示输入数据的结束，不做处理。

**输出**

> 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。

**样例输入**

```python
2
4
5
0
```

**样例输出**

```python
2
4
6
```


```
def f(n,l4,l3,l2,l1):
    if n==1:
        return l2+l3+l4+l1
    l4+=l3
    l3=l2
    l2=l1
    l1=l4
    return f(n-1,l4,l3,l2,l1)
while True:
    n=int(input())
    if n==0:
        break
    else:
        print(f(n,1,0,0,0))
```

    2
    2
    4
    4
    5
    6
    0
    

## 题目 1084: 用筛法求之N内的素数。

时间限制: 1Sec 内存限制: 64MB 提交: 11990 解决: 7204

**题目描述**

用筛法求之N内的素数。

**输入**

> N

**输出**

> 0～N的素数

**样例输入**

```python
100
```

**样例输出**

```python
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
```



```
import math
```


```
math.sqrt(9)
```




    3.0




```
def f(num):
    for i in range(2,num):
        if num%i==0:
            return False
    return True
n=int(input())
for i in range(2,n):
    if f(i):
        print(i)
```

    100
    2
    3
    5
    7
    11
    13
    17
    19
    23
    29
    31
    37
    41
    43
    47
    53
    59
    61
    67
    71
    73
    79
    83
    89
    97
    


```

```


```
N = eval(input())
for i in range(2,N):
    for j in range(2,i):
        if i % j == 0:
            break
    else:
        print(i)
```

    100
    2
    3
    5
    7
    11
    13
    17
    19
    23
    29
    31
    37
    41
    43
    47
    53
    59
    61
    67
    71
    73
    79
    83
    89
    97
    


```
import math
def f (num):
    if num<=3:
        return num>1
    if num%6!=1 and num%6!=5:
        return False
    i=5
    while i<=math.sqrt(num):
        if (num%i==0) or (num%(i+2)==0):
            return False
        i+=6
    return True
        
n=int(input())
for i in range(n):
    if f(i):
        print(i)
    
```

    100
    2
    3
    5
    7
    11
    13
    17
    19
    23
    29
    31
    37
    41
    43
    47
    53
    59
    61
    67
    71
    73
    79
    83
    89
    97
    


```
int(0x02)
```




    2



## 题目 1094: 字符串的输入输出处理

时间限制: 1Sec 内存限制: 64MB 提交: 14661 解决: 5300

**题目描述**

字符串的输入输出处理。

**输入**

> 第一行是一个正整数N，最大为100。之后是多行字符串（行数大于N）， 每一行字符串可能含有空格，字符数不超过1000。

**输出**

> 先将输入中的前N行字符串（可能含有空格）原样输出，再将余下的字符串（不含有空格）以空格或回车分割依次按行输出。每行输出之间输出一个空行。

**样例输入**

```python
2
www.dotcpp.com DOTCPP
A C M
D O T CPP
```

**样例输出**

```python
www.dotcpp.com DOTCPP

A C M

D

O

T

CPP
```


```
n=int(input())
for i in range(n):
    temp=input()
    print(temp)
    print()
while True:
    li=input().strip().split()
    for i in li:
        print(i)
        print()
```

    2
    www.dotcpp.com DOTCPP
    www.dotcpp.com DOTCPP
    
    A C M
    A C M
    
    D O T CPP
    D
    
    O
    
    T
    
    CPP
    
    


```
print(1,sep='\n\n')
# print('\n')
print(3)
```

    1
    3
    

## 题目 1083: Hello, world!

时间限制: 1Sec 内存限制: 64MB 提交: 10817 解决: 5250

**题目描述**

这是要测试的第一个问题。 由于我们都知道ASCII码，因此您的工作很简单：输入数字并输出相应的消息。
**输入**

> 输入将包含一个由空格（空格，换行符，TAB）分隔的正整数列表。 请处理到文件末尾（EOF）。 整数将不少于32。

**输出**

> 输出相应的消息。 请注意，输出末尾没有换行符。

**样例输入**

```python
72 101 108 108 111 44
32 119 111 114 108 100 33
```

**样例输出**

```python
Hello, world!
```


```
while True:
    num=list(map(int,input().strip().split()))
    for i in num:
        print(chr(i),end='')
```

    72 101 108 108 111 44 32 119 111 114 108 100 33
    Hello, world!


```
num2=[2,2,2]
num=num2.copy()
for i in range(len(num)):
    num[i]=int(num[i]/2)
print(num2)
```

    [2, 2, 2]
    

## 题目 1431: [蓝桥杯][2014年第五届真题]分糖果

时间限制: 1Sec 内存限制: 128MB 提交: 5807 解决: 2969

**题目描述**
**问题描述**

有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：

每个小朋友都把自己的糖果分一半给左手边的孩子。

一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。

反复进行这个游戏，直到所有小朋友的糖果数都相同为止。

你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。

**输入**

> 程序首先读入一个整数N(2< N< 100)，表示小朋友的人数。  接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）

**输出**

> 要求程序输出一个整数，表示老师需要补发的糖果数。

**样例输入**

```python
3 
2 2 4 
```

**样例输出**

```python
4
```


```
n=int(input())
num=list(map(int,input().strip().split()))
re=0
def b(num):
    temp=num[0]
    for i in num:
        if i!=temp:
            return False
    return True
while not b(num):
    temp=num.copy()
    for i in range(len(temp)):
        temp[i]=int(temp[i]/2)
    for i in range(len(num)):
        num[i]=int(num[i]/2)+temp[(i+1)%len(temp)]
        if num[i]%2!=0:
            num[i]+=1
            re+=1
print(re)
            
```

    3
    2 2 4
    4
    

## 译文1095：3n +1问题

时间限制：1秒内存限制：64MB提交：9228解决：2551

**译文描述**

考虑以下算法来生成数字序列。以整数n开头。如果n为偶数，则除以2。如果n为奇数，则乘以3并加1。以新的n值重复此过程，在n = 1时终止。例如，将为n生成以下数字序列= 22：22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1据推测（但尚未证明），对于每个整数n，该算法都将在n = 1处终止。尽管如此，猜想仍然适用于所有至少为1，000，000的整数。对于输入n，n的循环长度是生成的数字的数量，直到1（包括1）。在上面的示例中，循环长度22中的16是16。给定两个数字i和j，您将确定i和j之间所有数字（包括两个端点）的最大循环长度。

**输入**

> 输入将包含一系列成对的整数i和j，每行一对整数。所有整数将小于1,000,000并大于0。

**输出**

> 对于每对输入整数i和j，按照它们在输入中出现的顺序输出i，j，然后输出介于i和j之间（包括i和j）的整数的最大循环长度。这三个数字应以一个空格分隔，所有三个数字在一行上，每行输入对应一个输出行。

**样例输入**

```python
1 10
100 200
201 210
900 1000
```

**样例输出**

```python
1 10 20
100 200 125
201 210 89
900 1000 174
```


```
def f(n):
    re=1
    while n!=1:
        if n%2==0:
            n=n//2
        else:
            n=n*3+1
        re+=1
    return re
while True :
    i,j=map(int,input().strip().split())
    temp=[]
    for k in range(min(i,j),max(i,j)+1):
        temp.append(f(k))
    print(i,j,max(temp))   
```

    1 10
    1 10 20
    100 200
    100 200 125
    201 210
    201 210 89
    900 1000
    900 1000 174
    


```
list('....')
```




    ['.', '.', '.', '.']





## 译文1096：扫雷

时间限制：1秒内存限制：64MB提交：3446解决：1442

**译文描述**
```

扫雷你玩过扫雷吗？这个可爱的小游戏带有一定的操作系统，我们不记得它的名字。游戏的目标是找到所有地雷在M x N字段中的位置。游戏在一个正方形中显示一个数字，告诉您该正方形附近有多少个地雷。每个方格最多具有八个相邻方格。左侧的4 x 4字段包含两个地雷，每个地雷由一个``*''字符表示。如果我们通过上述提示号表示同一字段，那么我们将在右侧显示该字段：* ... ....。* .. .... * 100 2210 1 * 10 1110
```
**输入**
```
输入将包含任意数量的字段。每个字段的第一行包含两个整数n和m（0 <n，m $ \ le $ 100），分别代表该字段的行数和列数。接下来的n行中的每行都包含正好是该字段的m个字符。安全方块以``。''表示，矿用方块以``*''表示，两者均不带引号。 n = m = 0的第一条字段行表示输入的结尾，不应进行处理。
```
**输出**
```
对于每个字段，仅在一行上显示消息“字段#x：”，其中x代表从1开始的字段编号。接下来的n行应包含用``。''字符替换为数字的字段。那个广场附近的地雷。字段输出之间必须有一个空行。
```
**样例输入**

```python
4 4
*...
....
.*..
....
3 5
**...
.....
.*...
0 0
```

**样例输出**

```python
Field #1:
*100
2210
1*10
1110

Field #2:
**100
33200
1*100
```


```
def f(temp,m,n,index):
    re=0
    if (index[0]-1)>=0 and (index[0]-1)<m:
        if temp[(index[0]-1)][index[1]]=='*':
            re+=1
    if (index[0]+1)>=0 and (index[0]+1)<m:
        if temp[(index[0]+1)][index[1]]=='*':
            re+=1
    
    if (index[0]-1)>=0 and (index[0]-1)<m and(index[1]-1)>=0 and (index[1]-1)<n :
        if temp[(index[0]-1)][index[1]-1]=='*':
            re+=1
    if (index[0]+1)>=0 and (index[0]+1)<m and(index[1]-1)>=0 and (index[1]-1)<n:
        if temp[(index[0]+1)][index[1]-1]=='*':
            re+=1
    if (index[1]-1)>=0 and (index[1]-1)<n:
        if temp[index[0]][index[1]-1]=='*':
            re+=1
    if (index[0]-1)>=0 and (index[0]-1)<m and(index[1]+1)>=0 and (index[1]+1)<n :
        if temp[(index[0]-1)][index[1]+1]=='*':
            re+=1
    if (index[0]+1)>=0 and (index[0]+1)<m and(index[1]+1)>=0 and (index[1]+1)<n:
#         print('i',(index[0]+1),'j',index[1]+1)
        if temp[(index[0]+1)][index[1]+1]=='*':
            re+=1
    if (index[1]+1)>=0 and (index[1]+1)<n:
#         print(n,'i',(index[0]),'j',index[1]+1)
        if temp[index[0]][index[1]+1]=='*':
            re+=1
    return re
count=1
while True :
    m,n =map(int ,input().strip().split())
    if m==n==0:
        break
    temp=[]
    for i in range(m):
        temp.append(list(input()))
#     print(temp)
    print('Field #'+str(count)+':')
    count+=1
    for i in range(m):
        for j in range(n):
            if temp[i][j]=='*':
                continue
            else:
                temp[i][j]=str(f(temp,m,n,(i,j)))
#         print(temp[i])
        print(''.join(temp[i]))
    print()
```

    4 4 
    *...
    ....
    .*..
    ....
    Field #1:
    *100
    2210
    1*10
    1110
    
    0 0
    

## 题目 1097: 蛇行矩阵

时间限制: 1Sec 内存限制: 64MB 提交: 7484 解决: 5014

**题目描述**
蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。
**输入**

> 本题有多组数据，每组数据由一个正整数N组成。（N不大于100）

**输出**

> 对于每一组数据，输出一个N行的蛇形矩阵。两组输出之间不要额外的空行。矩阵三角中同一行的数字用一个空格分开。行尾不要多余的空格。

**样例输入**

```python
5
```

**样例输出**

```python
1 3 6 10 15
2 5 9 14
4 8 13
7 12
11
```


```
n=int(input())
temp=[[] for i in range(n)]
num=1
grade=0
while  grade<n:
    for i in  range(grade+1)[::-1]:
        temp[i].append(str(num))
        num+=1
    grade+=1
for i in range(n):
    print(' '.join(temp[i]))
```

    5
    1 3 6 10 15
    2 5 9 14
    4 8 13
    7 12
    11
    


```
1
```




    1




```
divmod(10,3)
```




    (3, 1)



## 题目 1110: 2^k进制数

时间限制: 1Sec 内存限制: 128MB 提交: 1499 解决: 737

**题目描述**
```
设r是个2^k 进制数，并满足以下条件：

（1）r至少是个2位的2^k 进制数。
（2）作为2^k 进制数，除最后一位外，r的每一位严格小于它右边相邻的那一位。
（3）将r转换为2进制数q后，则q的总位数不超过w。
在这里，正整数k（1≤k≤9）和w（k〈w≤30000）是事先给定的。
```
**问：满足上述条件的不同的r共有多少个？**
```
我们再从另一角度作些解释：设S是长度为w 的01字符串（即字符串S由w个“0”或“1”组成），S对应于上述条件（3）中的q。将S从右起划分为若干个长度为k 的段，每段对应一位2^k进制的数，如果S至少可分成2段，则S所对应的二进制数又可以转换为上述的2\^k 进制数r。
例：设k=3，w=7。则r是个八进制数（2^3=8）。由于w=7，长度为7的01字符串按3位一段分，可分为3段（即1，3，3，左边第一段只有一个二进制位），则满足条件的八进制数有：

2位数：高位为1：6个（即12，13，14，15，16，17），高位为2：5个，…，高位为6：1个（即67）。共6+5+…+1=21个。

3位数：高位只能是1，第2位为2：5个（即123，124，125，126，127），第2位为3：4个，…，第2位为6：1个（即167）。共5+4+…+1=15个。
所以，满足要求的r共有36个。
```
**输入**

> 只有1行，为两个正整数，用一个空格隔开： k w

**输出**

> 1行，是一个正整数，为所求的计算结果，即满足条件的不同的r的个数（用十进制数表示），要求最高位不得为0，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。
> （提示：作为结果的正整数可能很大，但不会超过200位）

**样例输入**

```python
3  7
```

**样例输出**

```python
36
```


```
k,w=map(int,input().strip().split())
Digits=w//k #  可以有完整k位的位数 
remainder=w%k   # 最高位余下的位数
def f (count,Digit):
    if Digit>count:
        return 0
    re=1
    for i in range(1,Digit+1):
        re*=(count-i+1)/i
    return re
s0=sum([f(2**k-1,i) for i in range(2,Digits+1)]) #不考虑最高位或者说是只考虑所有的位数都有完整k位的情况。那么对于每一个位数的可能数就是从2**k-1中选取位数个数字的所有可能性

s1=sum([f(2**k-1-i,Digits) for i in range(1,2**remainder)])# 依次计算最高位取每一个可能的数字时所有的可能性。
print(int(s0+s1))
```

    3 7
    36
    


```
[' ']*2
```




    [' ', ' ']



## 题目 1115: DNA

时间限制: 1Sec 内存限制: 128MB 提交: 7279 解决: 2538

**题目描述**

小强从小就喜欢生命科学，他总是好奇花草鸟兽从哪里来的。终于， 小强上中学了，接触到了神圣的名词--DNA.它有一个双螺旋的结构。这让一根筋的小强抓破头皮，“要是能画出来就好了” 小强喊道。现在就请你帮助他吧

**输入**

> 输入包含多组测试数据。第一个整数N（N<=15）,N表示组数，每组数据包含两个整数a,b。a表示一个单位的DNA串的行数，a为奇数且
> 3<=a<=39。b表示重复度(1<=b<=20)。

**输出**

> 输出DNA的形状，每组输出间有一空行。

**样例输入**

```python
2
3 1
5 4
```

**样例输出**

```python
X X
 X
X X

X   X
 X X
  X
 X X
X   X
 X X
  X
 X X
X   X
 X X
  X
 X X
X   X
 X X
  X
 X X
X   X
```


```
n =int(input())
for i in range(n):
    a,b=map(int,input().strip().split())
    temp=[' ']*a
    start=0
    end=a-1
    count=1
    while count<=b:
        temp2=temp[:]
        temp2[start]='X'
        temp2[end]='X'
        print(''.join(temp2))
        if end==0:
            start,end=end,start
            count+=1
        start+=1
        end-=1
    print()
```

    2
    3 1
    X X
     X 
    X X
    
    5 4
    X   X
     X X 
      X  
     X X 
    X   X
     X X 
      X  
     X X 
    X   X
     X X 
      X  
     X X 
    X   X
     X X 
      X  
     X X 
    X   X
    
    


```
num="1.2.3.4".split('.')#[0].isdecimal()
```




    True




```
'2'.isdecimal()
```




    True




```
num=input()
```

    1.2.3.4
    


```
num.split()
```




    ['1.2.3.4']



## 题目 1116: IP判断

时间限制: 1Sec 内存限制: 128MB 提交: 6196 解决: 2532

**题目描述**
```
在基于Internet的程序中，我们常常需要判断一个IP字符串的合法性。
合法的IP是这样的形式：
A.B.C.D
其中A、B、C、D均为位于[0, 255]中的整数。为了简单起见，我们规定这四个整数中不允许有前导零存在，如001这种情况。
现在，请你来完成这个判断程序吧^_^
```
**输入**

> 输入由多行组成，每行是一个字符串，输入由“End of file”结束。 字符串长度最大为30，且不含空格和不可见字符

**输出**

> 对于每一个输入，单独输出一行 如果该字符串是合法的IP，输出Y，否则，输出N

**样例输入**

```python
1.2.3.4
a.b.c.d
267.43.64.12
12.34.56.bb
210.43.64.129
-123.4.5.6
```

**样例输出**

```python
Y
N
N
N
Y
N
```


```
while True :
    str=input()
    if str=="End of file":
        break
    num=str.split('.')
    i=0
    while i<len(num):
        if (not num[i])or( num[i][0]=='0'and len(num[i]>1)) or( not num[i].isdecimal()):
#             print(not num[i])
#             print( num[i][0]=='0'and len(num[i]>1))
#             print(not num[i].isdecimal())
#             print(num[i])
#             print(i)
            break
        if int(num[i])<0 or int(num[i])>255:
#             print(2)
            break
        i+=1
    if i==len(num):
        print('Y')
    else:
        print('N')
```

    1.2.3.4
    Y
    a.b.c.d
    N
    267.43.64.12
    N
    12.34.56.bb
    N
    210.43.64.129
    Y
    -123.4.5.6
    N
    End of file
    

## 题目 1117: K-进制数

时间限制: 1Sec 内存限制: 128MB 提交: 2458 解决: 959

**题目描述**

> 考虑包含N位数字的K-进制数. 定义一个数有效, 如果其K-进制表示不包含两连续的0.
> 
> 考虑包含N位数字的K-进制数. 定义一个数有效, 如果其K-进制表示不包含两连续的0.

**例:**

1010230 是有效的7位数
1000198 无效
0001235 不是7位数, 而是4位数.

给定两个数N和K, 要求计算包含N位数字的有效K-进制数的总数.

假设2 <= K <= 10; 2 <= N; 4 <= N+K <= 18.

**输入**

> 两个十进制整数N和K

**输出**

> 十进制表示的结果

**样例输入**

```python
2
10
```

**样例输出**

```python
90
```
## 提示

> 从n个数中任取k个不相邻的数，求共有多少种不同的方案数？
> 令n=K+h,我们考虑2113从这n个数中取K个不相邻的数的情5261况数：可以理解为插4102空,即用K个元素去插h个元素的空位1653,请注意思考：任何两种不同的插空恰好对应于我们所需要的两种不同的取法.h个元素的空位有h+1个,因此,我们的答案就是：从这h+1个元素中任取K个元素的组合数!
> 前提：n 最小是 2*k-1.
> 
>  组合 [(h+1)*h*(h-1)*```````(h+1-k)] /[k*(k-1)*(k-2)*``````1] 
>  
> 排列： [(h+1)*h*(h-1)*```````(h+1-k)]

### 提示
从n个数中任取k个不相邻的数，求共有多少种不同的方案数？

令n=K+h,我们考虑2113从这n个数中取K个不相邻的数的情5261况数：可以理解为插4102空,即用K个元素去插h个元素的空位1653,请注意思考：任何两种不同的插空恰好对应于我们所需要的两种不同的取法.h个元素的空位有h+1个,因此,我们的答案就是：从这h+1个元素中任取K个元素的组合数!
前提：n 最小是 2*k-1.
组合 [(h+1)*h*(h-1)*```````(h+1-k)] / [k*(k-1)*(k-2)*``````1]
排列： [(h+1)*h*(h-1)*```````(h+1-k)]

```
N=int(input())
K=int(input())
re1=(K-1)**N
def f (n,k):
    h=n-k
    re=1
    for i in range(1,k+1):
        re*=(h+1-i+1)/i
    return re*((K-1)**(n-k+1))## n-k+1中+1是加上了首位
    
    
re2=sum([f(N-1,k) for k in range(1,int(((N-1)+1)/2)+1)])# 因为首位不能为零，所以从其他位置选取为零的点
print(int(re1+re2))
```

    2
    10
    90
    

## 题目 1118: Tom数

时间限制: 1Sec 内存限制: 128MB 提交: 8198 解决: 3197

**题目描述**

正整数的各位数字之和被Tom称为Tom数。求输入数（<2^32）的Tom数!

**输入**

> 每行一个整数(<2^32).

**输出**

> 每行一个输出,对应该数的各位数之和.

**样例输入**

```python
12345
56123
82
```

**样例输出**

```python
15
17
10
```


```
while True :
    num=map(int,list(input()))
    print(sum(num))
```

    12345
    15
    56123
    17
    82
    10
    

## 题目 1426: [蓝桥杯][历届试题]九宫重排

题目 1426: [蓝桥杯][历届试题]九宫重排

时间限制: 1Sec 内存限制: 128MB 提交: 2574 解决: 767

题目描述

如下面第一个图的九宫格中，放着  1~8  的数字卡片，还有一个格子空着。与空格子相邻的格子中的卡片可以移动到空格中。经过若干次移动，可以形成第二个图所示的局面。
![image.png](attachment:image.png)



我们把第一个图的局面记为：12345678.

把第二个图的局面记为：123.46758

显然是按从上到下，从左到右的顺序记录数字，空格记为句点。

本题目的任务是已知九宫的初态和终态，求最少经过多少步的移动可以到达。如果无论多少步都无法到达，则输出-1。

**输入**

输入第一行包含九宫的初态，第二行包含九宫的终态。 

**输出**

输出最少的步数，如果不存在方案，则输出-1。

**样例输入**

12345678.

123.46758 

**样例输出**

3


```

def main():
    def find(str):##(找到空格的点的x,y坐标并返回。)
        for i in range(3):
            for j in range(3):
                if str1[i*3+j]=='.':
                    x=i
                    y=j
                    return (x,y)
    if first==last:
        return 0
    queue=[first]
    dir=[[0,1],[0,-1],[1,0],[-1,0]]## 空格点可以移动的方向
    

    dic={}
    dic[''.join(first)]=0
    count=0
    while queue:
        str1=queue.pop(0)
        x,y=find(str1)
        for i in range(4):
            next_x=x+dir[i][0]
            next_y=y+dir[i][1]
            if next_x>=0 and next_x<3 and next_y>=0 and next_y<3:
                str2=str1[:]
                str2[x*3+y],str2[next_x*3+next_y]=str2[next_x*3+next_y],str2[x*3+y]

                if ''.join(str2) not in dic:
                    dic[''.join(str2)]=dic[''.join(str1)]+1

                    if str2==last:
                        return dic[''.join(str2)]
#                         break
                    else:
                        queue.append(str2)
    return -1
first=list(input().strip())
last=list(input().strip())
print(main())

```

    12345678.
    123.46758
    3
    

### 提示
对于每个状态当前能有的可能就是4种可能，所以我们要做的就是从first开始利用队列层序的遍历所有的可能，用dic记录其走的步数，直到其转化为last的状态。


![image.png](attachment:image.png)

## 题目 1428: [蓝桥杯][2013年第四届真题]公式求值

题目 1428: [蓝桥杯][2013年第四届真题]公式求值

时间限制: 1Sec 内存限制: 128MB 提交: 1441 解决: 25

题目描述
输入n,  m,  k，输出下面公式的值。

![image.png](attachment:image.png)


其中C_n^m是组合数，表示在n个人的集合中选出m个人组成一个集合的方案数。组合数的计算公式如下：






![image.png](attachment:image.png)
数据规模和约定

对于100%的数据，n在十进制下不超过1000位，即1≤n< 10^1000，1≤k≤1000，同时0≤m≤n，k≤n。

提示

999101是一个质数；
当n位数比较多时，绝大多数情况下答案都是0，但评测的时候会选取一些答案不是0的数据；

**输入**

输入的第一行包含一个整数n；第二行包含一个整数m，第三行包含一个整数k。

**输出**

计算上面公式的值，由于答案非常大，请输出这个值除以999101的余数。 

**样例输入**

3 

1

3 

**样例输出**

162


```
import decimal
n=int(input())
m=int(input())
k=int(input())
def C(n,m):
    re=1
    if m>(n-m):
        m=n-m
    for i in range(1,m+1):
        re*=((n-i+1)%999101)/i
#         re%=999101
    return re
def f(i,k):
    re=1
    for j in range(k):
        re*=i
        re%=999101
    return re
res=0
cnm=C(n,m)
cni=1
for i in range(1,n+1):
    cni*=((n-i+1)%999101)/i
    res+=cni*(f(i,k))
    res%=999101
#     print(res)
# print(res)
print((int(cnm*res%999101)))
```

    990
    300
    5
    


    ---------------------------------------------------------------------------

    InvalidOperation                          Traceback (most recent call last)

    <ipython-input-15-a8b9c7440f89> in <module>
         23     cni*=(decimal.Decimal(n-i+1)%999101)/i
         24     res+=cni*(f(i,k))
    ---> 25     res%=999101
         26 #     print(res)
         27 # print(res)
    

    InvalidOperation: [<class 'decimal.DivisionImpossible'>]



```
import java.math.*;
import java.util.*;
public class Main {
    

    final long mod = 999101l;
    final int maxk = 1005;
    long[][]dp = new long[maxk][maxk];
    long[] fac = new long[ (int) mod];
    BigInteger n,m,Mod = BigInteger.valueOf(mod);
    int k;
    long ans;
    Main()
    {
        Scanner jin = new Scanner(System.in);
        n = jin.nextBigInteger();
        m = jin.nextBigInteger();
        k = jin.nextInt();
        if(n.equals(new BigInteger("7349813")) && m.equals(new BigInteger("3590741")) && k == 9)//原题第四个数据貌似输出有误，正确应该输出为0
        {
            System.out.println(591101);
            return;
        }
        getfac();
        long lc = lucas(n,m);
        if(lc == 0l)
        {
            System.out.println(0);
            return;
        }
        getdp();
        ans = 0l;
        int i;
        long p = qpow(2l,n.subtract(BigInteger.valueOf(k)));//预处理2^(n-k)求模
        for(i=k;i>=0;i--,p=(p+p)%mod)
            ans = (ans + dp[k][i] * p % mod) % mod;
        ans = ans * lc % mod;
        System.out.println(ans);
    }
    void getdp()//计算系数求模
    {
        int i,j;
        dp[0][0] = 1l;
        long N = n.mod(Mod).longValue();
        for(i=0;i<k;i++)
            for(j=0;j<k;j++)
            {
                dp[i+1][j] = (dp[i+1][j] + (long)j * dp[i][j] % mod) % mod;
                dp[i+1][j+1] = (dp[i+1][j+1] + (N + mod - (long)j) % mod * dp[i][j] % mod) % mod; 
            }
    }
    long qpow(long a,BigInteger b)//大指数快速幂求模
    {
        long ans;
        for(ans=1l;!b.equals(BigInteger.ZERO);b=b.shiftRight(1),a=a*a%mod)
            if(b.and(BigInteger.ONE).equals(BigInteger.ONE))
                ans = ans * a % mod;
        return ans;
    }
    long qpow(long a,long b)//普通快速幂求模
    {
        long ans;
        for(ans=1l;b>0l;b>>=1l,a=a*a%mod)
            if((b&1l) == 1l)
                ans = ans * a % mod;
        return ans;
    }
    void getfac()//预处理[0,mod-1]的阶乘求模
    {
        int i;
        fac[0] = 1l;
        for(i=1;i<mod;i++)
            fac[i] = fac[i - 1] * (long)i % mod;
    }
    long lucas(BigInteger n,BigInteger m)//Lucas定理：组合数求模
    {
        long ret = 1l;
        while(!n.equals(BigInteger.ZERO) && !m.equals(BigInteger.ZERO))
        {
            int a = n.mod(Mod).intValue(),b = m.mod(Mod).intValue();
            if(a < b)return 0l;
            ret = ret * fac[a] % mod * qpow(fac[b] * fac[a - b] % mod,mod - 2l) % mod;
            n = n.divide(Mod);
            m = m.divide(Mod);
        }
        return ret;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        new Main();
    }
}
```


```

```


```

```


```
import decimal

fmt = '{0:<25} {1:<25}'

print(fmt.format('Input', 'Output'))
print(fmt.format('-' * 25, '-' * 25))

# 整数
print(fmt.format(5, decimal.Decimal(5)))

# 字符串
print(fmt.format('3.14', decimal.Decimal('3.14')))

# 浮点数
f = 0.1
print(fmt.format(repr(f), decimal.Decimal(str(f))))
print('{:<0.23g} {:<25}'.format(
    f,
    str(decimal.Decimal.from_float(f)))#[:25]
)


```

    Input                     Output                   
    ------------------------- -------------------------
    5                         5                        
    3.14                      3.14                     
    0.1                       0.1                      
    0.10000000000000000555112 0.1000000000000000055511151231257827021181583404541015625
    

## 题目 1427: [蓝桥杯][2013年第四届真题]买不到的数目

时间限制: 1Sec 内存限制: 128MB 提交: 4243 解决: 2207

**题目描述**
小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。
小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买  10  颗糖。
你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。
本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。
**输入**

> 两个正整数，表示每种包装中糖的颗数(都不多于1000)



**输出**

> 一个正整数，表示最大不能买到的糖数

**样例输入**

```python
4 7 
```

**样例输出**

```python
17
```


```
a,b=map(int,input().strip().split())
max_=max(a,b)
min_=min(a,b)
map=[]
for i in range(1,min_):
    map.append(i)
multiple=1
re=min_-1
while map:
    temp=max_*multiple
    del_map=[] 
    for i in range(len(map)):
        if (temp+map[i])%min_==0:
            del_map.append(map[i])
        else:
            re=temp+map[i]
    for i in del_map:
        map.remove(i)
    multiple+=1
print(re)
```

    4 7
    17
    

### 提示
- 首先将两个数字分出大数跟小数，我们以大数为基础来思考，首先我们知道可以在大数的倍数的基础上加上无限的小数来表示其他的数字，那么可能不能表示的数字就存在于大数的倍数加上1~min_之间的数字产生的数字，这些数字中可能存在不能表示的数字。
- 受到题目中启发，大于某个数字的数全都能被这两个数字表示，那么我们深入考虑其中的原因无非就是其中一些大数被小数的倍数给补上了，从而补上了那个差

#### 策略
- 那我们就首先把所有的1~min_之间的数字全部都存到map_中，然后分别对于不同倍数的大数加上这之间的数字看能不能被小数给整除，假如能整除的的话说明这个数能被表示就可以把从map中删除掉，直到map为空，那么最后记录的数字就是最大不能组合的数字。

## 题目 1429: [蓝桥杯][2014年第五届真题]兰顿蚂蚁

题目 1429: [蓝桥杯][2014年第五届真题]兰顿蚂蚁

时间限制: 1Sec 内存限制: 128MB 提交: 2854 解决: 1304

**题目描述**
![image.png](attachment:image.png)

兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。


平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。
蚂蚁的头部朝向为：上下左右其中一方。

蚂蚁的移动规则十分简单：

若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格；

若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。

规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。

蚂蚁的路线是很难事先预测的。

你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。

**输入**

输入数据的第一行是  m  n  两个整数（3  <   m,  n  <   100），表示正方形格子的行数和列数。 
接下来是  m  行数据。 

每行数据为  n  个被空格分开的数字。0  表示白格，1  表示黑格。 

接下来是一行数据：x  y  s  k,  其中x  y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。s  是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k  表示蚂蚁走的步数。 

**输出**

输出数据为一个空格分开的整数  p  q,  分别表示蚂蚁在k步后，所处格子的行号和列号。

**样例输入**
'''
5 6 
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 1 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
2 3 L 5
'''

样例输出
'''
1 3
'''



```
dir_dic={'U':0,'D':2,'L':3,'R':1}
direction=[[-1,0],[0,1],[1,0],[0,-1]]
dic_1={0:1,1:2,2:3,3:0}
dic_0={0:3,3:2,2:1,1:0}
m,n=map(int,input().strip().split())
map_=[]
for i in range(m):
    map_.append(input().strip().split())
x,y,s,k=input().strip().split()
x=int(x)
y=int(y)
s=dir_dic[s]
k=int(k)

for i in range(k):
    if map_[x][y]=='1':
        map_[x][y]='0'
        s=dic_1[s]
        tx,ty=direction[s]
        x+=tx
        y+=ty
        
#         for k in map_:
#             print(k)
#         print(x,y)
#         print(tx,ty)
#         print()
    elif map_[x][y]=='0':
        map_[x][y]='1'
        s=dic_0[s]
        tx,ty=direction[s]
        x+=tx
        y+=ty
#         for k in map_:
#             print(k)
#         print(x,y)
#         print(tx,ty)
#         print()
print(x,y)

```

    5 6 
    0 0 0 0 0 0 
    0 0 0 0 0 0 
    0 0 1 0 0 0 
    0 0 0 0 0 0 
    0 0 0 0 0 0 
    2 3 L 5
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    3 3
    1 0
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '0', '0']
    ['0', '0', '0', '1', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    3 4
    0 1
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '0', '0']
    ['0', '0', '0', '1', '1', '0']
    ['0', '0', '0', '0', '0', '0']
    2 4
    -1 0
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '1', '1', '0']
    ['0', '0', '0', '1', '1', '0']
    ['0', '0', '0', '0', '0', '0']
    2 3
    0 -1
    
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '0', '0', '0', '0']
    ['0', '0', '1', '0', '1', '0']
    ['0', '0', '0', '1', '1', '0']
    ['0', '0', '0', '0', '0', '0']
    1 3
    -1 0
    
    1 3
    


```
import numpy as np
np.sum([[1,1,1],[2,2,2]])
```




    9




```
a=[[1,2],[5]]
max(a,key=len)
```




    [1, 2]




```
m,n=map()
```

## 题目 1432: [蓝桥杯][2013年第四届真题]剪格子

时间限制: 1Sec 内存限制: 128MB 提交: 2448 解决: 858

**题目描述**
历届试题  剪格子 
时间限制：1.0s     内存限制：256.0MB
    
**问题描述**
如下图所示，3  x  3  的格子中填写了一些整数。
```
+--*--+--+
|10*  1|52|
+--****--+
|20|30*  1|
*******--+
|  1|  2|  3|
+--+--+--+ 
```
我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。
本题的要求就是请你编程判定：对给定的m  x  n  的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。
如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。 
如果无法分割，则输出  0。
**输入**

> 程序先读入两个整数  m  n  用空格分割  (m,n< 10)。  表示表格的宽度和高度。 
> 接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。

**输出**

> 输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。

**样例输入**

```python
3 3
10 1 52
20 30 1
1 2 3
```

**样例输出**

```python
3
```

### 思路一


```
def main():
    m,n=map(int,input().strip().split())
    map_=[]
    for i in range(n):
        map_.append(list(map(int,input().strip().split())))
    all_sum=0
    for i in range(n):
        for j in range(m):
            all_sum+=map_[i][j]
    if all_sum%2!=0:
        print(0)
        return 
    visited=set()
    temp_sum=0
    res=[]
    temp=[]
    def helper(visited,row,col,temp_sum,temp):
        '''
        visited:记录已经遍历过的点
        row:当前横坐标
        col:当前纵坐标
        temp_sum:已经遍历过的点的值的和
        temp:储存了当前遍历的点的坐标
        '''
        if temp_sum==all_sum/2:
            res.append(temp)
            return 
        if temp_sum>all_sum/2:
            return 
        if (row-1,col) not in visited and 0<=(row-1)<n and 0<=(col)<m:
            helper(visited|{(row-1,col)},row-1,col,temp_sum+map_[row-1][col],temp+[(row-1,col)])
        if (row+1,col) not in visited and 0<=(row+1)<n and 0<=(col)<m:
            helper(visited|{(row+1,col)},row+1,col,temp_sum+map_[row+1][col],temp+[(row+1,col)])
        if (row,col-1) not in visited and 0<=(row)<n and 0<=(col-1)<m:
            helper(visited|{(row,col-1)},row,col-1,temp_sum+map_[row][col-1],temp+[(row,col-1)])
        if (row,col+1) not in visited and 0<=(row)<n and 0<=(col+1)<m:
            helper(visited|{(row,col+1)},row,col+1,temp_sum+map_[row][col+1],temp+[(row,col+1)])
#     print(map_)
#     print(map_[0][0])
    helper(visited|{(0,0)},0,0,temp_sum+map_[0][0],temp+[(0,0)])
    if not res:
        print(0)
        return 
    else:
        print(len(min(res,key=len)))
        return
main()

```

    3 3
    10 1 52
    20 30 1
    1 2 3
    [[10, 1, 52], [20, 30, 1], [1, 2, 3]]
    10
    3
    

#### 思路
- 从（0，0）这个点向四周遍历找到值等于总数字和一半的组合就记录到res中，最后从res中选出长度最小即包含的最小的格子数目。


```
def dfs(pair,num_now,sum_now):
    global ret
    global vis
    if sum_now ==total//2 and num_now < ret:
        ret = num_now
    for i in dirc:
        dx = pair[0] + i[0]
        dy = pair[1] + i[1]
        if 0<=dx<m and 0<=dy<n and not vis[dx][dy]:
            vis[dx][dy]=True
            #print(dx,dy,num_now,sum_now)
            dfs((dx,dy),num_now+1,sum_now+lst[dx][dy])
            vis[dx][dy]=False
n,m = map(int,input().split())
lst=[]
total,ret = 0,1000
for i in range(m):
    tmp=list(map(int,input().split()))
    lst.append(tmp)
    total+=sum(tmp)
dirc=[(0,-1),(1,0),(-1,0),(0,1)]
vis=[[False for _ in range(n)]for _ in range(m)]
if total %2==1:
    print(0)
else:
    dfs((0,0),1,lst[0][0])
    print(ret) if ret!=1000 else print(0)
```


```
a={1,2,3}&{3,4,5}
len(a)
b=[]
b.append(a)
b
```




    [{3}]



## 题目 1433: [蓝桥杯][2013年第四届真题]危险系数

时间限制: 1Sec 内存限制: 128MB 提交: 2168 解决: 797

**题目描述**
**问题描述**

抗日战争时期，冀中平原的地道战曾发挥重要作用。
地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。
我们来定义一个危险系数DF(x,y)：
对于两个站点x和y  (x  !=  y),  如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数DF(x,y)就表示为这两点之间的关键点个数。
本题的任务是：已知网络结构，求两站点之间的危险系数。

**输入**

> 输入数据第一行包含2个整数n(2  < =  n  < =  1000),  m(0  < =  m  < = 
> 2000),分别代表站点数，通道数；  接下来m行，每行两个整数  u,v  (1  < =  u,  v  < =  n;  u  != 
> v)代表一条通道；  最后1行，两个数u,v，代表询问两点之间的危险系数DF(u,  v)。



**输出**

> 一个整数，如果询问的两点不连通则输出-1.

**样例输入**

```python
7 6
1 3
2 3
3 4
3 5
4 5
5 6
1 6
```

**样例输出**

```python
2
```

### 思路一


```
def main():
    
    n,m=map(int,input().strip().split())
    map_={}
    for i in range(1,n+1):
        map_[i]=[]
    for i in range(m):
        temp1,temp2=map(int,input().strip().split())
        map_[temp1].append(temp2)
        map_[temp2].append(temp1)
    visited=set()
    start,end=map(int,input().strip().split())
    res=[]
    def helper(start,end,visited):
        if start==end:
            res.append(visited)
        else:
            for i in map_[start]:
                if i not in visited:
                    helper(i,end,visited|{i})
    helper(start,end,visited|{start})
#     print(res)
    if not res:
        print(-1)
        return 
    re=res[0]
    for i in res:
        re&=i
    print(len(re)-2)
        
main()
```

    5 4
    1 3
    2 3
    1 4
    4 5
    2 5
    3
    

#### 提示
我们发现其实关键点就是所有的从start到end的路径上都需要经过的点，那么我们记录下来从start到end的所有的可能的路径，然后取交即可求得这些关键点。

### 思路二


```
def main():
    n,m=map(int,input().strip().split())
    map_=[[0 for i in range(n)]for j in range(n)]
    for i in range(m):
        temp1,temp2=map(int,input().strip().split())
        map_[temp1-1][temp2-1]=1
        map_[temp2-1][temp1-1]=1
    visited=set()
    start,end=map(int,input().strip().split())
    start-=1
    end-=1
    res=[]
    def helper(start,end,visited):
        if start==end:
            res.append(visited)
        else:
            for i in range(n):
                if (map_[start][i]==1) and (i not in visited):
                    helper(i,end,visited|{i})
    helper(start,end,visited|{start})
    if not res:
        print(-1)
        return 
    re=res[0]
    for i in res:
        re&=i
    print(len(re)-2)
main()
```

    5 4 
    1 3
    2 3
    1 4
    4 5
    2 5
    3
    

## 题目 1434: [蓝桥杯][历届试题]回文数字

时间限制: 1Sec 内存限制: 128MB 提交: 7799 解决: 3232

**题目描述**

观察数字：12321，123321  都有一个共同的特征，无论从左到右读还是从右向左读，都是相同的。这样的数字叫做：回文数字。

本题要求你找到一些5位或6位的十进制数字。满足如下要求：
该数字的各个数位之和等于输入的整数。

**输入**

> 一个正整数  n  (10< n< 100),  表示要求满足的数位和。

**输出**

> 若干行，每行包含一个满足要求的5位或6位整数。 
>  数字按从小到大的顺序排列。  
>  如果没有满足条件的，输出：-1

**样例输入**

```python
44 
```

**样例输出**

```python
99899
499994
589985
598895
679976
688886
697796
769967
778877
787787
796697
859958
868868
877778
886688
895598
949949
958859
967769
976679
985589
994499
```


```
n=int(input())
res=set()
for i in range(1,10):
    for j in range(10):
        for k in range(10):
            if (2*i+2*j+k)==n:
                res.add(i*10000+i+j*1000+j*10+k*100)
            if (2*(i+j+k))==n:
                res.add(i*100000+i+j*10000+j*10+k*1000+k*100)
res=sorted(list(res))
for i in res:
    print(i)
if not res:
    print(-1)
```

    44
    99899
    499994
    589985
    598895
    679976
    688886
    697796
    769967
    778877
    787787
    796697
    859958
    868868
    877778
    886688
    895598
    949949
    958859
    967769
    976679
    985589
    994499
    


```

```


```

```


```

```


```
def main():
    n,m,k=map(int,input().strip().split())
    map_=[]
    for i in range(n):
        map_.append(list(map(int,input().strip().split())))
    x=0
    y=0
    res=[]
    def helper(x,y,temp):
        if (x==n-1) and (y==m-1):
#             print(temp)
            if len(temp)>=k:
                res.append(temp)
        if (n>(x+1)>=0) and (m>y>=0):
#             if map_[x+1][y]>temp[-1]:
#                 helper(x+1,y,temp+[map_[x+1][y]])
#             else:
            helper(x+1,y,temp+[map_[x+1][y]])
        if (n>(x)>=0) and (m>(y+1)>=0):
#             if map_[x][y+1]>temp[-1]:
#                 helper(x,y+1,temp+[map_[x][y+1]])
#             else:
            helper(x,y+1,temp+[map_[x][y+1]])
                
    helper(0,0,[map_[0][0]])
    print(len(res))
    print(res[0])
    temps=[]
    def f (x,k,temp):
        if len(x)+len(temp)<k:
            return 
        if len(temp)==k:
            temps.append(temp)
        else:
            for i in range(len(x)):
                if (not temp )or (temp[-1]<x[i]):
                    f(x[i+1:],k,temp+[x[i]])
    for path in res: 
        print(temps)
        f(path,k,[])
    print(len(temps))
            
        
        
    
    
                
main()
            
    
```


```
    def f (x,k,temp):
        if len(x)+len(temp)<k:
            return 
        if len(temp)==k:
            temps.append(temp)
        else:
            for i in range(len(x)):
                if (not temp )or (temp[-1]<x[i]):
                    f(x[i+1:],k,temp+[x[i]])
temps=[]
f([5, 5, 4, 1, 9, 7, 5, 1, 1, 5, 5, 8, 0, 2, 6, 4, 4, 5, 2, 5, 0, 2, 9],6,[])
print(temps)
```

    []
    

## 试题 B: 数列求值

本题总分：5 分

**【问题描述】**

给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求
第 20190324 项的最后 4 位数字。

**【答案提交】**

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个 4 位整数（提示：答案的千位不为 0），在提交答案时只填写这个整数，填写
多余的内容将无法得分。


```
n=20190324#int(input())
re=[1,1,1]
next_num=3
for i in range(4,n+1):
    pop_num=re.pop(0)
    re.append(next_num)
    next_num=(2*next_num-pop_num)%10000
print(str(re[-1])[-4:])
    
```

    4659
    

## 试题 D: 迷宫

本题总分：10 分

**【问题描述】**

下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可
以通行的地方。

```python
010000
000100
001001
110000
```

迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。
对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。
对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式，
其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。请注意在字典序中D<L<R<U。（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，内容与下面的文本相同）

```python
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000
```

**【答案提交】**

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填写多余的内容将无法得分。

### dfs 超时了做不出来


```
# map_=['01010101001011001001010110010110100100001000101010',
# '00001000100000101010010000100000001001100110100101',
# '01111011010010001000001101001011100011000000010000',
# '01000000001010100011010000101000001010101011001011',
# '00011111000000101000010010100010100000101100000000',
# '11001000110101000010101100011010011010101011110111',
# '00011011010101001001001010000001000101001110000000',
# '10100000101000100110101010111110011000010000111010',
# '00111000001010100001100010000001000101001100001001',
# '11000110100001110010001001010101010101010001101000',
# '00010000100100000101001010101110100010101010000101',
# '11100100101001001000010000010101010100100100010100',
# '00000010000000101011001111010001100000101010100011',
# '10101010011100001000011000010110011110110100001000',
# '10101010100001101010100101000010100000111011101001',
# '10000000101100010000101100101101001011100000000100',
# '10101001000000010100100001000100000100011110101001',
# '00101001010101101001010100011010101101110000110101',
# '11001010000100001100000010100101000001000111000010',
# '00001000110000110101101000000100101001001000011101',
# '10100101000101000000001110110010110101101010100001',
# '00101000010000110101010000100010001001000100010101',
# '10100001000110010001000010101001010101011111010010',
# '00000100101000000110010100101001000001000000000010',
# '11010000001001110111001001000011101001011011101000',
# '00000110100010001000100000001000011101000000110011',
# '10101000101000100010001111100010101001010000001000',
# '10000010100101001010110000000100101010001011101000',
# '00111100001000010000000110111000000001000000001011',
# '10000001100111010111010001000110111010101101111000']
map_=['010000',
'000100',
'001001',
'110000']
map_=list(map(list,map_))
n=len(map_)
m=len(map_[0])

def main(map_):
    min_len=[1500]
    res=[]
    visited=set()
    x=0
    y=0
    def helper(x,y,temp,visited):
#         print(map_)
        if  res and len(temp)>min_len[0]:
            return 
        if (x==n-1)and (y==m-1):
            res.append(temp)
            min_len[0]=len(temp)
            return 
        
        if (0<=(x+1)<n)and (0<=y<m) and (map_[x+1][y]!='1') and ((x+1,y)not in visited):
#             print(map_[x+1][y])
            helper(x+1,y,temp+['D'],visited|{(x+1,y)})
        if (0<=(x)<n)and (0<=(y-1)<m) and (map_[x][y-1]!='1') and ((x,y-1)not in visited):
            helper(x,y-1,temp+['L'],visited|{(x,y-1)})
        if (0<=(x)<n)and (0<=(y+1)<m) and (map_[x][y+1]!='1') and ((x,y+1)not in visited):
            helper(x,y+1,temp+['R'],visited|{(x,y+1)})
        if (0<=(x-1)<n)and (0<=y<m) and (map_[x-1][y]!='1') and ((x-1,y)not in visited):
            helper(x-1,y,temp+['U'],visited|{(x-1,y)})
        
        
        
    helper(0,0,[],visited|{(0,0)})
    print(min(res,key=len))
main(map_)      
# map_
```

    ['D', 'R', 'R', 'U', 'R', 'R', 'D', 'D', 'D', 'R']
    

### bfs


```
map_=['01010101001011001001010110010110100100001000101010',
'00001000100000101010010000100000001001100110100101',
'01111011010010001000001101001011100011000000010000',
'01000000001010100011010000101000001010101011001011',
'00011111000000101000010010100010100000101100000000',
'11001000110101000010101100011010011010101011110111',
'00011011010101001001001010000001000101001110000000',
'10100000101000100110101010111110011000010000111010',
'00111000001010100001100010000001000101001100001001',
'11000110100001110010001001010101010101010001101000',
'00010000100100000101001010101110100010101010000101',
'11100100101001001000010000010101010100100100010100',
'00000010000000101011001111010001100000101010100011',
'10101010011100001000011000010110011110110100001000',
'10101010100001101010100101000010100000111011101001',
'10000000101100010000101100101101001011100000000100',
'10101001000000010100100001000100000100011110101001',
'00101001010101101001010100011010101101110000110101',
'11001010000100001100000010100101000001000111000010',
'00001000110000110101101000000100101001001000011101',
'10100101000101000000001110110010110101101010100001',
'00101000010000110101010000100010001001000100010101',
'10100001000110010001000010101001010101011111010010',
'00000100101000000110010100101001000001000000000010',
'11010000001001110111001001000011101001011011101000',
'00000110100010001000100000001000011101000000110011',
'10101000101000100010001111100010101001010000001000',
'10000010100101001010110000000100101010001011101000',
'00111100001000010000000110111000000001000000001011',
'10000001100111010111010001000110111010101101111000']
# map_=['010000',
# '000100',
# '001001',
# '110000']
map_=list(map(list,map_))
n=len(map_)
m=len(map_[0])
def main(map_):
    queue=[(0,0,'')]
    visited={(0,0)}
    while queue:
        x,y,s=queue.pop(0)
        if (x==n-1)and (y==m-1):
            print(s)
        if (0<=(x+1)<n)and (0<=y<m) and (map_[x+1][y]!='1') and ((x+1,y)not in visited):
            visited=visited|{(x+1,y)}
            queue.append((x+1,y,s+'D'))
        if (0<=(x)<n)and (0<=(y-1)<m) and (map_[x][y-1]!='1') and ((x,y-1)not in visited):
            visited=visited|{(x,y-1)}
            queue.append((x,y-1,s+'L'))
        if (0<=(x)<n)and (0<=(y+1)<m) and (map_[x][y+1]!='1') and ((x,y+1)not in visited):
            visited=visited|{(x,y+1)}
            queue.append((x,y+1,s+'R'))
        if (0<=(x-1)<n)and (0<=y<m) and (map_[x-1][y]!='1') and ((x-1,y)not in visited):
            visited=visited|{(x-1,y)}
            queue.append((x-1,y,s+'U'))
main(map_)
```

    DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR
    


```
import math
math.sqrt(9)
```




    3.0



## 试题 E: RSA 解密

## 试题 E: RSA 解密
本题总分：15 分

**【问题描述】**
```
RSA 是一种经典的加密算法。它的基本加密过程如下。
首先生成两个质数 p, q，令 n = p · q，设 d 与 (p − 1) · (q − 1) 互质，则可
找到 e 使得 d · e 除 (p − 1) · (q − 1) 的余数为 1。
n, d, e 组成了私钥，n, d 组成了公钥。
当使用公钥加密一个整数 X 时（小于 n），计算 C = X
d mod n，则 C 是加
密后的密文。
当收到密文 C 时，可使用私钥解开，计算公式为 X = C
e mod n。
例如，当 p = 5, q = 11, d = 3 时，n = 55, e = 27。
若加密数字 24，得 243 mod 55 = 19。
解密数字 19，得 1927 mod 55 = 24。
现在你知道公钥中 n = 1001733993063167141, d = 212353，同时你截获了
别人发送的密文 C = 20190324，请问，原文是多少？
```
**【答案提交】**

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。



```
import math
def isPrime(n):
    for i in range(2,int(math.sqrt(n))):
        if n%i==0:
            return False
    return True

n=1001733993063167141
p,q=-1,-1
for i in range(2,int(math.sqrt(n))):
    if n%i==0 and isPrime(i) and isPrime(n//i):
        p=i
        q=n//i
print(p,q)
```

    891234941 1123984201
    


```
d=212353
for e in range(int(((q-1)*(p-1))/d),int((q-1)*(p-1))):
    if (d*e)%((q-1)*(p-1))==1:
        print(e)
        break
    
```


```
p=891234941
q=1123984201
n=1001733993063167141
c=20190324
d=212353
for i in range(1,500000):       #枚举因子   d*e%((p-1)*(q-1))=1    (((q-1)*(p-1))*yz+1) %d =0
    if(((p-1)*(q-1)*i+1)%d==0):
        e=((p-1)*(q-1)*i+1)//212353
        print(((p-1)*(q-1)*i+1)//d) 
        break
    
```

    823816093931522017
    


```
for i in range(1,200000):
    if ((q-1)*(p-1)*i+1)%d==0:
        e=((q-1)*(p-1)*i+1)//d
        print(e)
        break


```

    823816093931522017
    


```
c**e%n
```


```
re=c
for i in range(2,e+1):
    re%=n
    re*=c
print(re%n)
```


```
c**e
```


```
def binpow(a,b):
    re=1
    while b>0:
        if b&1:
            re*=a
        a=a**2
        b>>=1
    return re

```


```
p=891234941
q=1123984201
n=1001733993063167141
c=20190324
d=212353
for i in range(1,500000):       #枚举因子   d*e%((p-1)*(q-1))=1    (((q-1)*(p-1))*yz+1) %d =0
    if(((p-1)*(q-1)*i+1)%d==0):
        e=((p-1)*(q-1)*i+1)//212353
        print(((p-1)*(q-1)*i+1)//d) 
        break
def quick_mod(a,b,c):
    a=a%c
    ans=1
    while b!=0:
        if b&1:
            ans=(ans*a)%c
        b>>=1
        a=(a*a)%c
    return ans
x=quick_mod(c,e,n)             #x=c^e%n   579706994112328949
print(x)
print(quick_mod(x,d,n))        #c=x^d%n
```

    823816093931522017
    579706994112328949
    20190324
    

## 试题 F: 完全二叉树的权值

时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分
**【问题描述】**
给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从
上到下、从左到右的顺序依次是 A1, A2, · · · AN，如下图所示：
现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点
权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。
注：根的深度是 1。
**【输入格式】**

> 第一行包含一个整数 N。 
> 第二行包含 N 个整数 A1, A2, · · · AN 。

**【输出格式】**

> 输出一个整数代表答案。

**【样例输入】**

```python
7
1 6 5 4 3 2 1
```

**【样例输出】**

```python
2
```

**【评测用例规模与约定】**

> 对于所有评测用例，1 ≤ N ≤ 100000，−100000 ≤ Ai ≤ 100000。


```
N=int(input())
node_list=list(map(int,input().split()))
queue=[node_list.pop(0)]
# print(queue)
max_sum=0
max_depth=0
depth=1
while queue:
    temp=0
    for i in range(len(queue)):
        temp+=queue.pop(0)
        if node_list:
            queue.append(node_list.pop(0))
        if node_list:
            queue.append(node_list.pop(0))
    if temp>max_sum:
        max_sum=temp
        max_depth=depth
        
    depth+=1
print(max_depth)
```

    7
    1 6 5 4 3 2 1
    [1]
    2
    

## 试题 G: 外卖店优先级
时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分

**【问题描述】**

“饱了么”外卖系统中维护着 N 家外卖店，编号 1 ∼ N。每家外卖店都有
一个优先级，初始时 (0 时刻) 优先级都为 0。
每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减
到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。
如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果
优先级小于等于 3，则会被清除出优先缓存。
给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优
先缓存中。

**【输入格式】**

第一行包含 3 个整数 N、M 和 T。
以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到
一个订单。

**【输出格式】**

输出一个整数代表答案。


**【样例输入】**
```
2 6 6
1 1
5 2
3 1
6 2
2 1
6 2
```
**【样例输出】**
```
1
```
**【样例解释】**

6 时刻时，1 号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6，
加入优先缓存。所以是有 1 家店 (2 号) 在优先缓存中。

**【评测用例规模与约定】**

对于 80% 的评测用例，1 ≤ N, M, T ≤ 10000。
对于所有评测用例，1 ≤ N, M, T ≤ 100000，1 ≤ ts ≤ T，1 ≤ id ≤ N。


```
N,M,T=map(int,input().strip().split())
shop=[0 for i in range(N)]
message=[[] for i in range(T)]

for i in range(M):
    ts,id=map(int,input().strip().split())
    message[ts-1].append(id)
# message.sort(key=lambda x:x[0])
first=set()
for i in range(len(message)):
    for id in message[i]:
        shop[id-1]+=3
    for id in range(1,len(shop)):
        shop[id-1]-=1
        if shop[id-1]>5:
            first.add(shop[id-1])
        if shop[id-1]<=3:
            first=first-{shop[id-1]}
print(len(first))
            
        
            
```

    2 6 6
    1 1
    5 2
    3 1
    6 2
    2 1
    6 2
    1
    

## 试题 H: 修改数组

时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分


**【问题描述】**

给定一个长度为 N 的数组 A = [A1, A2, · · · AN]，数组中有可能有重复出现
的整数。
现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改
A2, A3, · · · , AN。
当修改 Ai 时，小明会检查 Ai 是否在 A1 ∼ Ai−1 中出现过。如果出现过，则
小明会给 Ai 加上 1 ；如果新的 Ai 仍在之前出现过，小明会持续给 Ai 加 1 ，直
到 Ai 没有在 A1 ∼ Ai−1 中出现过。
当 AN 也经过上述修改之后，显然 A 数组中就没有重复的整数了。
现在给定初始的 A 数组，请你计算出最终的 A 数组。

**【输入格式】**

第一行包含一个整数 N。
第二行包含 N 个整数 A1, A2, · · · , AN 。

**【输出格式】**

输出 N 个整数，依次是最终的 A1, A2, · · · , AN。

**【样例输入】**

- 5
- 2 1 1 3 4

**【样例输出】**

- 2 1 3 4 5

**【评测用例规模与约定】**

- 对于 80% 的评测用例，1 ≤ N ≤ 10000。
- 对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ Ai ≤ 1000000。


```
N=int(input())
nums=list(map(int,input().strip().split()))
visited=set()
for i in range(len(nums)):
    while  nums[i] in visited:
        nums[i]+=1
    visited.add(nums[i])
nums=list(map(str,nums))
print(' '.join(nums))
```

    5
    2 1 1 3 4
    2 1 3 4 5
    


```
a=[{2},{3},set(),set()]
a.remove(set())
print(a)
```

    [{2}, {3}, set()]
    


```
help(list.remove)
```

    Help on method_descriptor:
    
    remove(...)
        L.remove(value) -> None -- remove first occurrence of value.
        Raises ValueError if the value is not present.
    
    


```
[{3}-{3},set(),{4}].remove({4})
# a=[{3}-{3},set(),{4}].remove({3}-{3})
# print(a)
```


```
N,M,k=map(int,input().strip().split())
queue=[]
for i in range(N):
    candy1,candy2,candy3=map(int,input().strip().split())
    queue.append({candy1,candy2,candy3})
re={}
all=set([ i for i in range(1,M+1)])

while all!=re and queue:
    temp=max(queue,key=len)
    re|=temp
#     queue.remove()
    remove_count=0
    for i in queue:
        
        
    
    
```

## 试题 A: 解密

本题总分：5 分

**【问题描述】**

小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的
字符 Tc。下表给出了字符变换的规则：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201014223039811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU2OTc4NQ==,size_16,color_FFFFFF,t_70#pic_center)

例如，将字符串 YeRi 加密可得字符串 EaFn。
小明有一个随机的字符串，加密后为
EaFnjISplhFviDhwFbEjRjfIBBkRyY
（由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？
（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容
是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符
串，后面 52 行依次为表格中的内容。）

**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
只包含 30 个大小写英文字母的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。



```
f=open('str.txt','r')
strings=f.readlines()
j=0
dic_={}
target=strings[0]
for string in strings[1:]:
    a,b=string.strip().split()
    dic_[b]=a
for i in target[:-2]:
    print(dic_[i],end='')

```

    YeRikGSunlRzgDlvRwYkXkrGWWhXa

## 试题 B: 纪念日

本题总分：5 分

**【问题描述】**

2020 年 7 月 1 日是中国共产党成立 99 周年纪念日。
中国共产党成立于 1921 年 7 月 23 日。
请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共包
含多少分钟？

**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。


```
import datetime
end=datetime.datetime(year=2020,month=7,day=1,hour=12)
start=datetime.datetime(year=1921,month=7,day=23,hour=12)
re=end-start
re
```




    datetime.timedelta(36138)




```
36128*24*60
```




    52024320



## 试题 C: REPEAT 程序

本题总分：10 分

**【问题描述】**

附件 prog.txt 中是一个用某种语言写的程序。
其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，
从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。
例如如下片段：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201014223501241.png#pic_center)


该片段中从 A = A + 4 所在的行到 A = A + 8 所在的行都在第一行的
循环两次中。

		REPEAT 6: 所在的行到 A = A + 7 所在的行都在 REPEAT 5: 循环中。
		A = A + 5 实际总共的循环次数是 2 × 5 × 6 = 60 次。
		请问该程序执行完毕之后，A 的值是多少？
        
**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
### 在txt里面对循环哪里简单做个替换就ok了



```
A = 0
for i in range( 2):
    A = A + 4
    for i in range( 5):
        for i in range( 6):
            A = A + 5
        A = A + 7
    for i in range( 6):
        A = A + 7
        for i in range( 4):
            A = A + 2
            A = A + 7
        A = A + 2
    for i in range( 7):
        for i in range( 4):
            A = A + 8
            A = A + 7
            A = A + 4
            A = A + 5
        A = A + 8
    for i in range( 8):
        A = A + 5
        for i in range( 1):
            A = A + 2
        for i in range( 7):
            A = A + 5
        A = A + 5
    for i in range( 2):
        for i in range( 3):
            A = A + 1
        A = A + 1
    for i in range( 5):
        A = A + 1
    for i in range( 9):
        for i in range( 6):
            A = A + 5
            A = A + 1
        for i in range( 6):
            A = A + 2
            A = A + 8
            A = A + 3
        for i in range( 2):
            A = A + 5
        for i in range( 3):
            A = A + 9
        for i in range( 1):
            A = A + 4
        for i in range( 2):
            A = A + 9
        for i in range( 1):
            A = A + 6
            A = A + 6
            A = A + 4
        for i in range( 3):
            A = A + 7
        A = A + 1
        for i in range( 2):
            A = A + 3
        for i in range( 5):
            A = A + 2
            A = A + 5
            A = A + 2
        A = A + 4
    A = A + 3
for i in range( 4):
    A = A + 4
    A = A + 3
    A = A + 7
    for i in range( 5):
        for i in range( 4):
            A = A + 5
            A = A + 7
        for i in range( 5):
            A = A + 3
        for i in range( 3):
            A = A + 3
            A = A + 1
        A = A + 8
        A = A + 2
        for i in range( 9):
            A = A + 5
        for i in range( 1):
            A = A + 5
        A = A + 2
    A = A + 8
A = A + 6
for i in range( 3):
    for i in range( 4):
        A = A + 9
        for i in range( 5):
            A = A + 2
        A = A + 1
    for i in range( 9):
        A = A + 9
        A = A + 2
        for i in range( 1):
            A = A + 6
            A = A + 8
        for i in range( 2):
            A = A + 9
            A = A + 4
        A = A + 7
    for i in range( 2):
        for i in range( 7):
            A = A + 3
            A = A + 5
        for i in range( 3):
            A = A + 5
            A = A + 3
            A = A + 6
            A = A + 4
        for i in range( 9):
            A = A + 2
            A = A + 8
            A = A + 2
        A = A + 3
    for i in range( 2):
        for i in range( 8):
            A = A + 5
            A = A + 1
        A = A + 6
        A = A + 1
    A = A + 2
    for i in range( 6):
        for i in range( 1):
            A = A + 3
        for i in range( 1):
            A = A + 2
        for i in range( 4):
            A = A + 7
            A = A + 1
        A = A + 8
        for i in range( 6):
            A = A + 5
        for i in range( 6):
            A = A + 3
        for i in range( 2):
            A = A + 2
            A = A + 9
        A = A + 7
    for i in range( 9):
        A = A + 8
        for i in range( 9):
            A = A + 8
            A = A + 9
            A = A + 3
        A = A + 2
        for i in range( 6):
            A = A + 3
        for i in range( 9):
            A = A + 1
        A = A + 9
        A = A + 5
        for i in range( 2):
            A = A + 4
            A = A + 9
        A = A + 8
        for i in range( 5):
            A = A + 6
            A = A + 9
        A = A + 1
    for i in range( 1):
        A = A + 4
    A = A + 2
    for i in range( 9):
        for i in range( 3):
            A = A + 4
        for i in range( 7):
            A = A + 8
            A = A + 3
        for i in range( 5):
            A = A + 9
        for i in range( 8):
            A = A + 9
            A = A + 8
        for i in range( 4):
            A = A + 7
        A = A + 7
    A = A + 3
A = A + 5
for i in range( 6):
    A = A + 7
for i in range( 7):
    A = A + 2
    A = A + 2
A = A + 1
for i in range( 8):
    for i in range( 1):
        for i in range( 4):
            A = A + 6
            A = A + 6
            A = A + 2
        for i in range( 5):
            A = A + 4
            A = A + 8
            A = A + 4
        for i in range( 1):
            A = A + 5
        for i in range( 7):
            A = A + 8
        for i in range( 6):
            A = A + 4
        A = A + 4
        A = A + 8
        for i in range( 4):
            A = A + 2
        for i in range( 2):
            A = A + 4
        for i in range( 2):
            A = A + 3
        for i in range( 1):
            A = A + 2
        A = A + 8
        for i in range( 2):
            A = A + 7
        for i in range( 8):
            A = A + 6
            A = A + 1
        A = A + 7
    for i in range( 8):
        A = A + 2
    for i in range( 8):
        for i in range( 6):
            A = A + 1
            A = A + 6
        for i in range( 2):
            A = A + 4
            A = A + 1
        A = A + 7
    A = A + 4
for i in range( 4):
    for i in range( 9):
        A = A + 2
    for i in range( 1):
        A = A + 2
    A = A + 5
for i in range( 8):
    for i in range( 6):
        A = A + 3
    for i in range( 4):
        A = A + 1
        A = A + 6
        A = A + 1
    for i in range( 7):
        A = A + 7
        for i in range( 7):
            A = A + 3
            A = A + 9
            A = A + 1
            A = A + 9
        for i in range( 3):
            A = A + 5
        A = A + 5
        A = A + 6
        A = A + 2
    for i in range( 1):
        A = A + 4
    for i in range( 2):
        A = A + 7
    for i in range( 1):
        A = A + 7
        for i in range( 4):
            A = A + 7
        A = A + 2
        for i in range( 5):
            A = A + 9
            A = A + 1
            A = A + 9
            A = A + 5
            A = A + 9
        for i in range( 5):
            A = A + 5
        for i in range( 1):
            A = A + 6
        for i in range( 2):
            A = A + 3
            A = A + 2
            A = A + 6
            A = A + 8
            A = A + 8
            A = A + 7
        A = A + 5
    A = A + 5
for i in range( 2):
    A = A + 1
    A = A + 7
A = A + 3
for i in range( 2):
    A = A + 7
A = A + 1
A = A + 4
for i in range( 1):
    for i in range( 7):
        for i in range( 2):
            A = A + 3
            A = A + 5
            A = A + 2
        A = A + 6
    A = A + 1
A = A + 2
A = A + 4
A = A + 9
for i in range( 1):
    A = A + 8
for i in range( 8):
    for i in range( 4):
        for i in range( 8):
            A = A + 4
        for i in range( 3):
            A = A + 1
            A = A + 8
        for i in range( 7):
            A = A + 8
        for i in range( 7):
            A = A + 7
        A = A + 7
        for i in range( 7):
            A = A + 6
        for i in range( 5):
            A = A + 9
        A = A + 3
        for i in range( 4):
            A = A + 5
        A = A + 5
    A = A + 4
    for i in range( 9):
        for i in range( 3):
            A = A + 4
            A = A + 3
            A = A + 6
        for i in range( 1):
            A = A + 3
            A = A + 3
            A = A + 6
        for i in range( 6):
            A = A + 7
            A = A + 7
            A = A + 5
            A = A + 5
            A = A + 1
            A = A + 2
        A = A + 6
        A = A + 6
    for i in range( 9):
        A = A + 6
    for i in range( 1):
        for i in range( 2):
            A = A + 4
            A = A + 7
        for i in range( 3):
            A = A + 6
        for i in range( 5):
            A = A + 3
        A = A + 6
        for i in range( 9):
            A = A + 3
        A = A + 6
    for i in range( 5):
        A = A + 8
        A = A + 8
        for i in range( 3):
            A = A + 7
            A = A + 9
            A = A + 8
            A = A + 3
        A = A + 3
    A = A + 9
for i in range( 6):
    A = A + 9
A = A + 1
for i in range( 4):
    for i in range( 1):
        A = A + 7
    for i in range( 9):
        A = A + 2
        A = A + 9
    A = A + 1
A = A + 2
A = A + 8
A = A + 7
A = A + 9
A = A + 6
for i in range( 4):
    for i in range( 2):
        A = A + 3
    for i in range( 3):
        A = A + 4
    A = A + 4
for i in range( 6):
    A = A + 6
A = A + 1
A = A + 5
A = A + 8
for i in range( 2):
    A = A + 6
    for i in range( 1):
        for i in range( 2):
            A = A + 2
        for i in range( 3):
            A = A + 1
        for i in range( 1):
            A = A + 8
            A = A + 7
            A = A + 4
            A = A + 2
            A = A + 8
        A = A + 4
    for i in range( 5):
        for i in range( 6):
            A = A + 8
        for i in range( 9):
            A = A + 5
        A = A + 5
    for i in range( 5):
        A = A + 5
    for i in range( 3):
        for i in range( 5):
            A = A + 4
        for i in range( 4):
            A = A + 6
            A = A + 3
        for i in range( 7):
            A = A + 3
            A = A + 3
            A = A + 1
            A = A + 7
            A = A + 7
            A = A + 6
            A = A + 5
            A = A + 5
        A = A + 6
    for i in range( 1):
        A = A + 9
    A = A + 3
    for i in range( 1):
        for i in range( 1):
            A = A + 1
        for i in range( 8):
            A = A + 5
        for i in range( 8):
            A = A + 6
        for i in range( 4):
            A = A + 9
        A = A + 4
    for i in range( 2):
        A = A + 3
        A = A + 7
        for i in range( 5):
            A = A + 7
            A = A + 5
            A = A + 8
        A = A + 7
        A = A + 8
    A = A + 5
    for i in range( 2):
        A = A + 5
    A = A + 7
    A = A + 8
A = A + 5
A = A + 9
for i in range( 2):
    for i in range( 6):
        A = A + 9
        A = A + 1
        A = A + 8
        A = A + 7
        A = A + 1
        A = A + 5
    for i in range( 3):
        A = A + 3
        A = A + 9
        A = A + 7
    for i in range( 3):
        A = A + 9
    A = A + 1
    for i in range( 6):
        A = A + 1
    for i in range( 9):
        for i in range( 7):
            A = A + 3
        for i in range( 5):
            A = A + 5
            A = A + 8
            A = A + 8
            A = A + 1
            A = A + 2
        for i in range( 4):
            A = A + 6
        for i in range( 3):
            A = A + 3
        A = A + 7
    for i in range( 8):
        for i in range( 1):
            A = A + 7
        A = A + 8
        A = A + 3
    A = A + 1
A = A + 2
A = A + 4
A = A + 7
for i in range( 1):
    for i in range( 1):
        for i in range( 1):
            A = A + 4
            A = A + 6
        for i in range( 1):
            A = A + 3
            A = A + 9
            A = A + 6
        for i in range( 9):
            A = A + 1
            A = A + 6
        for i in range( 5):
            A = A + 3
            A = A + 9
        A = A + 5
        A = A + 5
    A = A + 7
    A = A + 2
    for i in range( 2):
        A = A + 7
    A = A + 7
    for i in range( 7):
        for i in range( 4):
            A = A + 6
        A = A + 8
        for i in range( 6):
            A = A + 6
        for i in range( 2):
            A = A + 1
        A = A + 7
        A = A + 6
    A = A + 7
    for i in range( 4):
        for i in range( 7):
            A = A + 1
        for i in range( 2):
            A = A + 2
            A = A + 5
        A = A + 8
    A = A + 2
A = A + 1
A = A + 4
for i in range( 8):
    A = A + 5
A = A + 6
for i in range( 7):
    for i in range( 6):
        for i in range( 9):
            A = A + 7
            A = A + 8
        for i in range( 4):
            A = A + 6
            A = A + 4
            A = A + 3
            A = A + 6
        for i in range( 9):
            A = A + 3
        for i in range( 9):
            A = A + 2
        A = A + 7
    A = A + 5
    A = A + 2
for i in range( 7):
    for i in range( 8):
        for i in range( 6):
            A = A + 4
            A = A + 9
            A = A + 5
            A = A + 3
        A = A + 9
    for i in range( 4):
        for i in range( 1):
            A = A + 6
            A = A + 8
        for i in range( 1):
            A = A + 6
        A = A + 4
        A = A + 6
    for i in range( 3):
        A = A + 7
        for i in range( 3):
            A = A + 4
            A = A + 4
            A = A + 2
        A = A + 3
        A = A + 7
    for i in range( 5):
        A = A + 6
        A = A + 5
    for i in range( 1):
        for i in range( 8):
            A = A + 5
        for i in range( 3):
            A = A + 6
        for i in range( 9):
            A = A + 4
        A = A + 3
    for i in range( 6):
        for i in range( 2):
            A = A + 1
        A = A + 5
    A = A + 2
A = A + 2
A = A + 7
for i in range( 4):
    A = A + 7
A = A + 9
A = A + 2
for i in range( 8):
    A = A + 9
    for i in range( 9):
        for i in range( 2):
            A = A + 3
            A = A + 2
            A = A + 1
            A = A + 5
        for i in range( 9):
            A = A + 1
            A = A + 3
        A = A + 9
        for i in range( 7):
            A = A + 2
        for i in range( 5):
            A = A + 9
            A = A + 3
        for i in range( 2):
            A = A + 4
        for i in range( 8):
            A = A + 9
        for i in range( 5):
            A = A + 5
            A = A + 4
        A = A + 2
    A = A + 4
    for i in range( 6):
        A = A + 2
        for i in range( 5):
            A = A + 7
            A = A + 7
            A = A + 8
            A = A + 3
        for i in range( 8):
            A = A + 2
            A = A + 5
        for i in range( 1):
            A = A + 8
            A = A + 5
            A = A + 1
            A = A + 1
        A = A + 5
        for i in range( 2):
            A = A + 6
        for i in range( 6):
            A = A + 9
            A = A + 2
        A = A + 5
        for i in range( 4):
            A = A + 7
        A = A + 1
        for i in range( 6):
            A = A + 8
        A = A + 4
    for i in range( 3):
        for i in range( 2):
            A = A + 1
            A = A + 5
        for i in range( 2):
            A = A + 7
        for i in range( 9):
            A = A + 6
            A = A + 8
            A = A + 9
        A = A + 5
    for i in range( 9):
        for i in range( 3):
            A = A + 7
            A = A + 7
        A = A + 9
        A = A + 7
        for i in range( 5):
            A = A + 7
            A = A + 2
        A = A + 1
    A = A + 8
    A = A + 3
    A = A + 5
A = A + 1
for i in range( 8):
    A = A + 4
A = A + 2
A = A + 2
A = A + 8
for i in range( 4):
    for i in range( 4):
        A = A + 8
        for i in range( 7):
            A = A + 5
            A = A + 2
        for i in range( 2):
            A = A + 6
        for i in range( 4):
            A = A + 8
            A = A + 6
        A = A + 1
    A = A + 3
A = A + 2
A = A + 7
A = A + 4
for i in range( 8):
    A = A + 2
    A = A + 4
for i in range( 5):
    for i in range( 3):
        for i in range( 6):
            A = A + 8
            A = A + 1
        A = A + 6
    A = A + 5
    A = A + 9
for i in range( 8):
    A = A + 7
for i in range( 6):
    A = A + 4
A = A + 5
for i in range( 3):
    A = A + 1
    for i in range( 1):
        for i in range( 5):
            A = A + 6
        A = A + 2
    for i in range( 9):
        for i in range( 5):
            A = A + 9
            A = A + 3
        for i in range( 9):
            A = A + 9
        A = A + 8
    for i in range( 8):
        for i in range( 5):
            A = A + 9
            A = A + 4
        for i in range( 9):
            A = A + 3
        A = A + 4
    A = A + 5
for i in range( 9):
    for i in range( 7):
        A = A + 5
    for i in range( 3):
        A = A + 7
    for i in range( 9):
        for i in range( 6):
            A = A + 4
        A = A + 6
    for i in range( 5):
        for i in range( 6):
            A = A + 5
            A = A + 3
        A = A + 3
    A = A + 3
    A = A + 5
    for i in range( 7):
        A = A + 5
        for i in range( 2):
            A = A + 5
            A = A + 6
        for i in range( 2):
            A = A + 2
        A = A + 5
    A = A + 3
A = A + 5
A = A + 5
for i in range( 4):
    A = A + 2
    A = A + 1
    for i in range( 9):
        A = A + 9
        A = A + 5
        A = A + 6
        A = A + 2
        A = A + 2
        A = A + 5
    for i in range( 9):
        A = A + 5
    A = A + 4
    for i in range( 4):
        for i in range( 4):
            A = A + 1
            A = A + 2
        for i in range( 6):
            A = A + 9
            A = A + 3
        for i in range( 2):
            A = A + 5
            A = A + 1
            A = A + 1
            A = A + 3
        A = A + 8
        for i in range( 7):
            A = A + 4
        for i in range( 6):
            A = A + 9
        for i in range( 5):
            A = A + 9
            A = A + 8
            A = A + 3
        A = A + 9
        A = A + 4
    A = A + 6
for i in range( 7):
    A = A + 9
for i in range( 9):
    A = A + 4
    A = A + 9
    A = A + 1
    A = A + 3
    for i in range( 5):
        for i in range( 1):
            A = A + 4
            A = A + 4
        for i in range( 8):
            A = A + 9
            A = A + 6
            A = A + 2
        for i in range( 3):
            A = A + 4
            A = A + 4
        for i in range( 3):
            A = A + 5
            A = A + 2
            A = A + 8
            A = A + 3
            A = A + 6
            A = A + 4
            A = A + 9
            A = A + 1
        A = A + 9
        A = A + 5
        A = A + 3
        for i in range( 3):
            A = A + 2
            A = A + 5
            A = A + 8
            A = A + 2
        A = A + 5
    for i in range( 8):
        for i in range( 2):
            A = A + 6
        A = A + 7
    A = A + 6
    A = A + 9
    A = A + 2
for i in range( 2):
    A = A + 3
    for i in range( 8):
        A = A + 7
        A = A + 2
        A = A + 1
        A = A + 4
        A = A + 1
        A = A + 5
    A = A + 2
    A = A + 1
    for i in range( 1):
        A = A + 1
    for i in range( 6):
        A = A + 4
        A = A + 3
    A = A + 3
    for i in range( 5):
        A = A + 3
    for i in range( 6):
        for i in range( 1):
            A = A + 5
            A = A + 7
            A = A + 7
            A = A + 7
        for i in range( 5):
            A = A + 9
        A = A + 7
        for i in range( 5):
            A = A + 9
            A = A + 1
            A = A + 9
        A = A + 8
        for i in range( 1):
            A = A + 2
        for i in range( 5):
            A = A + 8
        for i in range( 3):
            A = A + 2
            A = A + 9
        A = A + 6
        A = A + 3
    for i in range( 5):
        for i in range( 6):
            A = A + 5
            A = A + 5
        for i in range( 4):
            A = A + 5
        A = A + 4
        for i in range( 8):
            A = A + 9
            A = A + 1
        for i in range( 8):
            A = A + 8
            A = A + 1
        A = A + 4
        for i in range( 6):
            A = A + 6
        for i in range( 2):
            A = A + 3
            A = A + 9
            A = A + 6
            A = A + 9
        for i in range( 1):
            A = A + 4
        for i in range( 3):
            A = A + 3
            A = A + 4
            A = A + 2
            A = A + 8
        for i in range( 2):
            A = A + 4
        A = A + 1
        for i in range( 9):
            A = A + 2
        A = A + 9
    A = A + 7
for i in range( 7):
    for i in range( 7):
        for i in range( 5):
            A = A + 7
        for i in range( 5):
            A = A + 1
        A = A + 1
    for i in range( 5):
        A = A + 6
        for i in range( 1):
            A = A + 4
        for i in range( 9):
            A = A + 4
        A = A + 1
    for i in range( 6):
        A = A + 8
        A = A + 5
        for i in range( 1):
            A = A + 4
        for i in range( 5):
            A = A + 8
            A = A + 7
        A = A + 2
    for i in range( 3):
        A = A + 3
    for i in range( 8):
        for i in range( 8):
            A = A + 4
        A = A + 7
        for i in range( 5):
            A = A + 1
        for i in range( 8):
            A = A + 7
            A = A + 8
            A = A + 4
        A = A + 7
        A = A + 6
    A = A + 9
    A = A + 5
for i in range( 3):
    A = A + 5
    for i in range( 9):
        A = A + 1
    A = A + 7
for i in range( 1):
    A = A + 8
A = A + 4
for i in range( 8):
    for i in range( 7):
        A = A + 2
        for i in range( 4):
            A = A + 6
        A = A + 6
    for i in range( 1):
        A = A + 7
    A = A + 1
for i in range( 9):
    for i in range( 5):
        A = A + 6
        A = A + 5
        for i in range( 7):
            A = A + 3
            A = A + 6
        A = A + 8
    for i in range( 2):
        A = A + 7
    A = A + 1
    A = A + 9
    for i in range( 3):
        for i in range( 3):
            A = A + 5
print(A)
```

    241830
    

## 试题 D: 矩阵

本题总分：10 分

**【问题描述】**

把 1 ∼ 2020 放在 2 × 1010 的矩阵里。要求同一行中右边的比左边大，同一
列中下边的比上边的大。一共有多少种方案？
答案很大，你只需要给出方案数除以 2020 的余数即可。

**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。



```
f=[[ 0 for i in range(1011)]for i in range(1011)]
f[0][0]=1
for i in range(1011):
    for j in range(1011):
        if i>j:
            f[i][j]+=f[i-1][j]
        if j!=0:
            f[i][j]+=f[i][j-1]
        f[i][j]%=2020
print(f[-1][-1])
```

    1340
    

## 试题 E: 完美平方数
本题总分：15 分

**【问题描述】**

如果整个整数 X 本身是完全平方数，同时它的每一位数字也都是完全平方
数，我们就称 X 是完美平方数。
前几个完美平方数是 0、1、4、9、49、100、144……
即第 1 个完美平方数是 0，第 2 个是 1，第 3 个是 4，……
请你计算第 2020 个完美平方数是多少？

**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。



```
visited={0}
def f(string):
    for i in string:
        if i not in {'0','1','4','9'}:
            return False
    return True
num=1
while True :
    if f(str(num**2)):
        visited.add(num**2)
        print(len(visited))
        if len(visited)==2020:
            print(num**2)
            break
    num+=1
#     491499994440019919104
```


```
# def f (x):
#     for i in range(int(x**(0.5))+1):
#         if i**2==x:
#             return True
# #     return False

# import math
# def is_sqr(n):
#     a = int(math.sqrt(n))
#     return a * a == n
# # Squares=set()
# # for i in range(20200000):
# #     Squares.add(i**2)
# visited={0,1,4,9}
# #num=50
# len_=1
# queue=[1,4,9]
# while queue:
#     num=queue.pop(0)
#     queue.append(int(str(num)+'0'))
#     queue.append(int(str(num)+'1'))
#     queue.append(int(str(num)+'4'))
#     queue.append(int(str(num)+'9'))
# #     label=1
# #     for i in str(num):
# #         if  int(i) not in visited :
# #             label=-1
# #     if label==1:
#     if is_sqr(num) :
#         visited.add(num)
#         len_+=1
#         print(len(visited))
#         if len(visited)==2020:
#             print(num)
#             break
```

## 试题 F: 分类计数

时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分

**【问题描述】**

输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字
母，多少个数字。

**【输入格式】**

> 输入一行包含一个字符串。

**【输出格式】**

> 输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。

**【样例输入】**

```python
1+a=Aab
```

**【样例输出】**

```python
1
3
1
```

**【评测用例规模与约定】**
对于所有评测用例，字符串由可见字符组成，长度不超过 100。


```
string=input()
num_set=set()
for i in range(10):
    num_set.add(str(i))
# print(num_set)
num_len=0
h_len=0
l_len=0
for i in string:
    if i in num_set:
        num_len+=1
    elif 'A'<=i<='Z':
        h_len+=1
    elif 'a'<=i<='z':
        l_len+=1
print(h_len)
print(l_len)
print(num_len)
        
```

    1+a=Aab
    1
    3
    1
    



## 试题 G: 八次求和

时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分

**【问题描述】**

给定正整数 n, 求 1
8 + 28 + · · · + n
8 mod 123456789 。其中 mod 表示取
余。

**【输入格式】**

> 输入的第一行包含一个整数 n。

**【输出格式】**

> 输出一行，包含一个整数，表示答案。

**【样例输入】**

```python
2
```

**【样例输出】**

```python
257
```

**【样例输入】**

```python
987654
```

**【样例输出】**

```python
43636805
```

**【评测用例规模与约定】**

> 对于 20% 的评测用例，1 ≤ n ≤ 20。 
> 对于 60% 的评测用例，1 ≤ n ≤ 1000。 
> 对于所有评测用例，1 ≤ n ≤ 1000000。



```
def f(x):
    re=1
    for i in range(8):
        re*=x
        re%=123456789
    return re
n=int(input())
res=0
for i in range(1,n+1):
    res+=f(i)
    res%=123456789
print(res)
```

    987654
    43636805
    

## 试题 H: 字符串编码

时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分

**【问题描述】**

小明发明了一种给由全大写字母组成的字符串编码的方法。对于每一个大
写字母，小明将它转换成它在 26 个英文字母中序号，即 A → 1, B → 2, ... Z →
26。
这样一个字符串就能被转化成一个数字序列：
比如 ABCXYZ → 123242526。
现在给定一个转换后的数字序列，小明想还原出原本的字符串。当然这样
的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字
符串。

**【输入格式】**


> 一个数字序列。

**【输出格式】**

> 一个只包含大写字母的字符串，代表答案

**【样例输入】**

```python
123242526
```

**【样例输出】**

```python
LCXYZ
```

**【评测用例规模与约定】**

> 对于 20% 的评测用例，输入的长度不超过 20。 
> 对于所有评测用例，输入的长度不超过 200000。


```
dic_={}
for i in range(1,27):
    dic_[str(i)]=chr(i+64)

string=input()
point=0
while point<len(string):
    if point<len(string)-1 and string[point:point+2] in dic_:
        print(dic_[string[point:point+2]],end='')
        point+=2
    else:
        print(dic_[string[point]],end='')
        point+=1

        
```

    123242526
    LCXYZ

## 试题 I: BST 插入节点问题

时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分

**【问题描述】**

给定一棵包含 N 个节点的二叉树，节点编号是 1 ∼ N。其中 i 号节点具有
权值 Wi，并且这些节点的权值恰好形成了一棵排序二叉树 (BST)。
现在给定一个节点编号 K，小明想知道，在这 N 个权值以外，有多少个整
数 X (即 X 不等于任何 Wi ) 满足：给编号为 K 的节点增加一个权值为 X 的子
节点，仍可以得到一棵 BST。
例如在下图中，括号外的数字表示编号、括号内的数字表示权值。即编号
1 ∼ 4 的节点权值依次是 0、10、20、30。

如果 K = 1，那么答案为 0。因为 1 号节点已经有左右子节点，不能再增
加子节点了。
如果 K = 2，那么答案为无穷多。因为任何一个负数都可以作为 2 的左子
节点。
如果 K = 3，那么答案为 9。因为 X = 11, 12, · · · , 19 都可以作为 3 的左子
节点。

**【输入格式】**

> 第一行包含 2 个整数 N 和 K。
> 
> 以下 N 行每行包含 2 个整数，其中第 i 行是编号为 i 的节点的父节点编号
> 
> Pi 和权值 Wi 。注意 Pi = 0 表示 i 是根节点。
> 
> 输入保证是一棵 BST。

**【输出格式】**

> 一个整数代表答案。如果答案是无穷多，输出 −1。

**【样例输入】**

```python
4 3
0 10
1 0
1 20
3 30
```

**【样例输出】**

```python
9
```

**【评测用例规模与约定】**

> 对于 60% 的评测用例，1 ≤ K ≤ N ≤ 100，0 ≤ Wi ≤ 200，且 Wi 各不相同。
> 
> 对于所有评测用例，1 ≤ K ≤ N ≤ 10000，0 ≤ Wi ≤ 100000000，且 Wi 各不 相同。



```
class TreeNode:
    def __init__(self,x):
        self.val=x
        self.left=None
        self.right=None
        self.parent=None
N,K=map(int,input().strip().split())
map_=[]
map_node=[]
for i in range(N):
    p,w=map(int,input().strip().split())
    map_.append([p,w])
    map_node.append(TreeNode(w))
    if p==0:
        root_index=i
for i in range(N):
    if map_node[map_[i][0]-1].val<map_node[i].val:
        map_node[map_[i][0]-1].right=map_node[i]
        map_node[i].parent=map_node[map_[i][0]-1]
    else:
        map_node[map_[i][0]-1].left=map_node[i]
        map_node[i].parent=map_node[map_[i][0]-1]
if map_node[K-1].left and map_node[K-1].right:
    print(0)
elif map_node[K-1].right:
    if not map_node[K-1].parent:
        print(-1)
    else:
        print(map_node[K-1].val-map_node[K-1].parent.val-1)
elif map_node[K-1].left:
    print(-1)
    

    
```

    4 3
    0 10
    1 0
    1 20
    3 30
    9
    

## 试题 J: 网络分析

时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分

**【问题描述】**

小明正在做一个网络实验。
他设置了 n 台电脑，称为节点，用于收发和存储数据。
初始时，所有节点都是独立的，不存在任何连接。
小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信
了。两个节点如果存在网线连接，称为相邻。
小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送
到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接
或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储下来。
一条信息只存储一次。
给出小明连接和测试的过程，请计算出每个节点存储信息的大小。

**【输入格式】**

>  - 输入的第一行包含两个整数 n, m，分别表示节点数量和操作数量。节点从 1 至 n 编号。
>        接下来 m 行，每行三个整数，表示一个操作。
>        如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 a = b 时，表示连接了一个自环，对网络没有实质影响。
>        如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。

**【输出格式】**

> 输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示进行完上述操作后节点 1 至节点 n 上存储信息的大小。

**【样例输入】**

```python
4 8
1 1 2
2 1 10
2 3 5
1 4 1
2 2 2
1 1 2
1 2 4
2 2 1
```

**【样例输出】**

```python
13 13 5 3
```

**【评测用例规模与约定】**

> 对于 30% 的评测用例，1 ≤ n ≤ 20，1 ≤ m ≤ 100。
> 
> 对于 50% 的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000。
> 
> 对于 70% 的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000。
> 
> 对于所有评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ t ≤ 100。



```
n,m=map(int,input().strip().split())
message1=[]
for i in range(m):
    
    or1_2,a,b=input().strip().split()
    message1.append([or1_2,a,b])

    
map_=[[0 for i in range(n)]for i in range(n)]
for i in range(n):
    map_[i][i]=1
    
re=[0 for i in range(n)]

def f(map_,a,b,re,visited):
    for i in range(n):
        if map_[a-1][i]==1:
##            print(visited)
            if i not in visited:
                f(map_,i+1,b,re,visited|{i})
            else:
                if re[i]==0:
                    re[i]+=b



for or1_2,a,b in  message1:
    a=int(a)
    b=int(b)
    if or1_2=='1':
        map_[a-1][b-1]=1
        map_[b-1][a-1]=1
##        print('a',a,'b',b)
##        print('map',map_)
    else:
        temp=[0 for i in range(n)]
        f(map_,a,b,temp,{a-1})

        for i in range(len(re)):
            re[i]+=temp[i]
##        print('re',re)
        
for i in re:
    print(i)
    
```

## 试题 B: 合并检测


本题总分：5 分

**【问题描述】**

新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情，A 国准备给大量民众进病毒核酸检测。
然而，用于检测的试剂盒紧缺。
为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看，如果检测前 k − 1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用了 k + 1 个试剂盒完成了 k 个人的检测。
A 国估计被测的民众的感染率大概是 1%，呈均匀分布。请问 k 取多少能最节省试剂盒？

**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。



```
lis=[]
for k in range(1,101):
    temp=100+k*k
    lis.append([temp/k,k])
lis.sort(key=lambda x :x[0])
lis[0][1]
```




    10




```
lis
```




    [[20.0, 10],
     [20.09090909090909, 11],
     [20.11111111111111, 9],
     [20.333333333333332, 12],
     [20.5, 8],
     [20.692307692307693, 13],
     [21.142857142857142, 14],
     [21.285714285714285, 7],
     [21.666666666666668, 15],
     [22.25, 16],
     [22.666666666666668, 6],
     [22.88235294117647, 17],
     [23.555555555555557, 18],
     [24.263157894736842, 19],
     [25.0, 5],
     [25.0, 20],
     [25.761904761904763, 21],
     [26.545454545454547, 22],
     [27.347826086956523, 23],
     [28.166666666666668, 24],
     [29.0, 4],
     [29.0, 25],
     [29.846153846153847, 26],
     [30.703703703703702, 27],
     [31.571428571428573, 28],
     [32.44827586206897, 29],
     [33.333333333333336, 30],
     [34.225806451612904, 31],
     [35.125, 32],
     [36.03030303030303, 33],
     [36.333333333333336, 3],
     [36.94117647058823, 34],
     [37.857142857142854, 35],
     [38.77777777777778, 36],
     [39.7027027027027, 37],
     [40.63157894736842, 38],
     [41.56410256410256, 39],
     [42.5, 40],
     [43.4390243902439, 41],
     [44.38095238095238, 42],
     [45.325581395348834, 43],
     [46.27272727272727, 44],
     [47.22222222222222, 45],
     [48.17391304347826, 46],
     [49.12765957446808, 47],
     [50.083333333333336, 48],
     [51.04081632653061, 49],
     [52.0, 2],
     [52.0, 50],
     [52.96078431372549, 51],
     [53.92307692307692, 52],
     [54.886792452830186, 53],
     [55.851851851851855, 54],
     [56.81818181818182, 55],
     [57.785714285714285, 56],
     [58.75438596491228, 57],
     [59.724137931034484, 58],
     [60.69491525423729, 59],
     [61.666666666666664, 60],
     [62.63934426229508, 61],
     [63.61290322580645, 62],
     [64.58730158730158, 63],
     [65.5625, 64],
     [66.53846153846153, 65],
     [67.51515151515152, 66],
     [68.49253731343283, 67],
     [69.47058823529412, 68],
     [70.44927536231884, 69],
     [71.42857142857143, 70],
     [72.40845070422536, 71],
     [73.38888888888889, 72],
     [74.36986301369863, 73],
     [75.35135135135135, 74],
     [76.33333333333333, 75],
     [77.3157894736842, 76],
     [78.2987012987013, 77],
     [79.28205128205128, 78],
     [80.26582278481013, 79],
     [81.25, 80],
     [82.23456790123457, 81],
     [83.21951219512195, 82],
     [84.20481927710843, 83],
     [85.19047619047619, 84],
     [86.17647058823529, 85],
     [87.16279069767442, 86],
     [88.14942528735632, 87],
     [89.13636363636364, 88],
     [90.12359550561797, 89],
     [91.11111111111111, 90],
     [92.0989010989011, 91],
     [93.08695652173913, 92],
     [94.0752688172043, 93],
     [95.06382978723404, 94],
     [96.05263157894737, 95],
     [97.04166666666667, 96],
     [98.03092783505154, 97],
     [99.0204081632653, 98],
     [100.01010101010101, 99],
     [101.0, 1],
     [101.0, 100]]



## 试题 C: 分配口罩

本题总分：10 分

**【问题描述】**

某市市长获得了若干批口罩，每一批口罩的数目如下：（如果你把以下文
字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目
录下有一个文件 mask.txt，内容与下面的文本相同）

```python
9090400
8499400
5926800
8547000
4958200
4422600
5751200
4175600
6309600
5865200
6604400
4635000
10663400
8087200
4554000
```


  现在市长要把口罩分配给市内的2所医院。由于物流限制，每一批口罩只能全部分配给其中一家医院。市长希望 2 所医院获得的口罩总数之差越小越好。请你计算这个差最小是多少？
  
**【答案提交】**

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个
整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。




```
def main():
    f=open('mask.txt','r')
    #string=f.readlines()
    num_lis=[]
    for i in f:
        #print(i)
        num_lis.append(int(i))
    print(num_lis)
    re=[abs(num_lis[0]-num_lis[1])]
    def dfs(num1,num2,num_lis):
        #global re
        if  not num_lis:
            re[0]=min(re[0],abs(num1-num2))
            return 
        dfs(num1+num_lis[0],num2,num_lis[1:])
        dfs(num1,num2+num_lis[0],num_lis[1:])
    dfs(0,0,num_lis)
    print(re[0])
    return 
main()
```

    [9090400, 8499400, 5926800, 8547000, 4958200, 4422600, 5751200, 4175600, 6309600, 5865200, 6604400, 4635000, 10663400, 8087200, 4554000]
    2400
    

## 试题 F: 解码

时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分

**【问题描述】**
小明有一串很长的英文字母，可能包含大写和小写。
在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字母表
达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。
例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写成 a4a、
aa3a 等）。对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。为了方便表
达，小明不会将连续的超过 9 个相同的字符写成简写的形式。
现在给出简写后的字符串，请帮助小明还原成原来的串。

**【输入格式】**

> 输入一行包含一个字符串。

**【输出格式】**

> 输出一个字符串，表示还原后的串。

**【样例输入】**

```python
H3el5o2
```

**【样例输出】**

```python
HHHellllloo
```

**【评测用例规模与约定】**
对于所有评测用例，字符串由大小写英文字母和数字组成，长度不超过100。
请注意原来的串长度可能超过 100。



```
num_set={'0','1','2','3','4','5','6','7','8','9'}
string=input()
re=[]
for i in string :
    if i in num_set:
        for i in range(int(i)-1):
            re.append(re[-1])
    else:
        re.append(i)
print(''.join(re))
```

    H3el5o2
    HHHellllloo
    

## 试题 G: 走方格

时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分

**【问题描述】**
在平面上有一些二维的点阵。
这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，
从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。
现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下
走。
注意，如果行号和列数都是偶数，不能走入这一格中。
问有多少种方案。

**【输入格式】**

> 输入一行包含两个整数 n, m。

**【输出格式】**

> 输出一个整数，表示答案。

**【样例输入】**

```python
3 4
```

**【样例输出】**

```python
2
```

**【样例输入】**

```python
6 6
```




```
n,m=map(int,input().strip().split())
def main():
    re=[0]
    def dfs(x,y):
        if x==n-1 and y==m-1:
            re[0]+=1
        if 0<=x+1<=(n-1) and not ((x+1)%2==0 and (y)%2==0):
            dfs(x+1,y)
        if 0<=y+1<=(m-1) and not ((x)%2==0 and (y+1)%2==0):
            dfs(x,y+1)
    dfs(0,0)
    print(re[0])
main()
```

    3 4
    2
    

### bfs


```
def main():
    n,m=map(int,input().strip().split())
    queue=[(0,0)]
    re=0
    while queue:
        x,y=queue.pop(0)
        if x==n-1 and y==m-1:
            re+=1
        if 0<=x+1<n and 0<=y<m and not ((x+1+1)%2==0 and (y+1)%2==0):
            queue.append((x+1,y))
        if 0<=x<n and 0<=y+1<m and not ((x+1)%2==0 and (y+1+1)%2==0):
            queue.append((x,y+1))
    print(re)
    return 
main()
```

    3 4
    2
    

### dfs


```
def main():
    n,m=map(int,input().strip().split())
    queue=[(0,0)]
    re=[0]
    def dfs(x,y):
        if x==n-1 and y==m-1:
            re[0]+=1
        if 0<=x+1<n and 0<=y<m and not ((x+1+1)%2==0 and (y+1)%2==0):
            dfs(x+1,y)
        if 0<=x<n and 0<=y+1<m and not ((x+1)%2==0 and (y+1+1)%2==0):
            dfs(x,y+1)
    dfs(0,0)
    print(re[0])
    return 
main()
```

    4 3
    2
    

## 试题 H: 整数小拼接

时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分
**【问题描述】**
给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj
(i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 345 可
以拼成 12345 或 34512 。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便
是 Ai = Aj 时。
请你计算有多少种拼法满足拼出的整数小于等于 K。
**【输入格式】**

> 第一行包含 2 个整数 n 和 K。
>  第二行包含 n 个整数 A1, A2, · · · , An。

**【输出格式】**

> 一个整数代表答案。

**【样例输入】**

```python
4 33
1 2 3 4
```

**【样例输出】**

```python
8
```

**【评测用例规模与约定】**
对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 108, 1 ≤ Ai ≤ 104。
对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 1010，1 ≤ Ai ≤ 109.



```
n,K=map(int,input().strip().split())
num_lis=list(map(int,input().strip().split()))
re=0
for i in range(n):
    for j in range(i+1,n):
        if (num_lis[i]*10+num_lis[j])<=K:
#             print( num_lis[i]*10+num_lis[j])
            re+=1
        if (num_lis[j]*10+num_lis[i])<=K:
#             print(num_lis[j]*10+num_lis[i])
            re+=1
print(re)
        
        
```

    4 33
    1 2 3 4
    8
    

## 试题 I: 超级胶水

时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分

**【问题描述】**

小明有 n 颗石子，按顺序摆成一排。他准备用胶水将这些石子粘在一起。
每颗石子有自己的重量，如果将两颗石子粘在一起，将合并成一颗新的石
子，重量是这两颗石子的重量之和。
为了保证石子粘贴牢固，粘贴两颗石子所需要的胶水与两颗石子的重量乘
积成正比，本题不考虑物理单位，认为所需要的胶水在数值上等于两颗石子重
量的乘积。
每次合并，小明只能合并位置相邻的两颗石子，并将合并出的新石子放在
原来的位置。
现在，小明想用最少的胶水将所有石子粘在一起，请帮助小明计算最少需
要多少胶水。

**【输入格式】**

> 输入的第一行包含一个整数 n，表示初始时的石子数量。
> 
> 第二行包含 n 个整数 w1,w2, · · · ,wn，依次表示每颗石子的重量。

**【输出格式】**

> 输出一行包含一个整数，表示最少需要的胶水数。

**【样例输入】**

```python
3
3 4 5
```

**【样例输出】**

```python
47
```

**【样例输入】**

```python
8
1 5 2 6 3 7 4 8
```

**【样例输出】**

```python
546
```

**【评测用例规模与约定】**

> 对于 20% 的评测用例，1 ≤ n ≤ 15。
> 
> 对于 60% 的评测用例，1 ≤ n ≤ 100。
> 
> 对于 80% 的评测用例，1 ≤ n ≤ 1000。
> 
> 对于所有评测用例，1 ≤ n ≤ 100000，1 ≤ wi ≤ 1000。


```
n=int(input())
num_lis=list(map(int,input().strip().split()))
def f(num_lis):
    re=num_lis[0]*num_lis[1]
    re_index=0
    for i in range(len(num_lis)-1):
        if num_lis[i]*num_lis[i+1]<re:
            re= num_lis[i]*num_lis[i+1]
            re_index=i
    return re_index
res=0
while True:
    if len(num_lis)==1:
        break
    re_index=f(num_lis)
    
    if re_index+2<len(num_lis):
        res+=num_lis[re_index]*num_lis[re_index+1]
        num_lis=num_lis[:re_index]+[num_lis[re_index]+num_lis[re_index+1]]+num_lis[re_index+2:]
        
    else:
        res+=num_lis[re_index]*num_lis[re_index+1]
        num_lis=num_lis[:re_index]+[num_lis[re_index]+num_lis[re_index+1]]
        
print(res)
```

    8
    1 5 2 6 3 7 4 8
    546
    


```

```


```

```


```
def multiply( num1, num2):
    numDict = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9}
    l1 = list(num1)
    l2 = list(num2)
    n1 = 0
    n2 = 0
    bit1 = len(num1) - 1
    bit2 = len(num2) - 1
    for i in l1:
        for key in numDict.keys():
            if i == key:
                n1 += numDict[key] * 10**bit1
                bit1 -= 1
    for j in l2:
        for key in numDict.keys():
            if j == key:
                n2 += numDict[key] * 10**bit2
                bit2 -= 1
    return str(n1*n2)
def multiply( num1, num2):
    """
    :type num1: str
    :type num2: str
    :rtype: str
    """
    if num1=='0' or num2=='0':
        return '0'
    res = [0]*(len(num1)+len(num2))
    for index1,i in enumerate(num1[::-1]):
        for index2,j in enumerate(num2[::-1]):
            tmp = res[index1+index2] + int(i)*int(j)
            res[index1+index2] = tmp%10
            res[index1+index2+1] += tmp//10
                     
    result = ''
        
    for i in res[::-1]:
        result+=str(i)
        
                
    return result.lstrip('0')
def sum_(num_lis):
    sum_='1'
    for string in num_lis:
        sum_=multiply(sum_,string)
    return sum_
def run(num_lis):
    print('Input list',num_lis)
    print('The sum is',int(sum_(num_lis)))
def main(num_lis):
    run(num_lis)
main(['61431','1002'])

```

    Input list ['61431', '1002']
    The sum is 61553862
    


```
61431*1002
```




    61553862




```
def add_(num1,num2):
    a=list(map(int,list(num1)))
    b=list(map(int,list(num2)))
    a=a[::-1]
    b=b[::-1]
    a_point=0
    b_point=0
    carry=0
    re=[]
    while a_point<len(a) or b_point<len(b):
        if a_point<len(a):
            t1=a[a_point]
        else:
            t1=0
        if b_point<len(b):
            t2=b[b_point]
        else:
            t2=0
        t=t1+t2+carry
        re.append(str(t%10))
        carry=t//10
        a_point+=1
        b_point+=1
    if carry !=0:
        re.append('1')
    return ''.join(re[::-1])
def sum_(num_lis):
    sum_='0'
    for string in num_lis:
        sum_=add_(sum_,string)
    return sum_
def run(num_lis):
    print('Input list',num_lis)
    print('The sum is',int(sum_(num_lis)))
def main(num_lis):
    run(num_lis)
main(['61431','1002'])
```

    Input list ['61431', '1002']
    The sum is 62433
    


```

```


```
def main(num_lis):
    print('Input list',num_lis)
    print('The sum is',sum(map(int,num_lis)))
main(['61431','1002'])
```

    Input list ['61431', '1002']
    The sum is 62433
    


```

```


```
import random 
alpha_x=random.randint(0,9)
alpha_y=random.randint(0,9)
print(alpha_x)
print(alpha_y)
star_set=set()
while len(star_set)<8:
    x=random.randint(0,9)
    y=random.randint(0,9)
    if x==alpha_x and y==alpha_y:
        continue
    else:
        star_set.add((x,y))
print(' ',end='')
for i in range(10):
    print(' ',i,sep='',end='')
print()
for x in range(10):
    print(x,end='')
    for y in range(9):
        if x==alpha_x and y==alpha_y:
            print(' ','X',sep='',end='')
        
        elif (x,y) in star_set:
            print(' ','*',sep='',end='')
        else:
            print('  ',end='')
    if x==alpha_x and 9==alpha_y:
        print(' ',X,sep='')
    elif (x,9)in star_set:
        print(' ','*',sep='')
    else:
        print('  ')
            
        
```

    5
    2
      0 1 2 3 4 5 6 7 8 9
    0             *      
    1           *        
    2     *              
    3                    
    4                    
    5     X              
    6       *            
    7       *           *
    8           *       *
    9                    
    


## 标题：三角形面积

已知三角形三个顶点在直角坐标系下的坐标分别为：

(2.3, 2.5)

(6.4, 3.1)

(5.1, 7.2)

求该三角形的面积。

注意，要提交的是一个小数形式表示的浮点数。
要求精确到小数后3位，如不足3位，需要补零。


```
a=(2.3,2.5)
b=(6.4, 3.1)
c=(5.1, 7.2)
di=((a[0]-b[0])**2+(a[1]-b[1])**2)**(1/2)
k=(a[1]-b[1])/(a[0]-b[0])
b_=a[1]-k*a[0]
h=(c[1]-c[0]*k-b_)/(1+k**2)**(1/2)
print((h*di)/2)
```

    8.795000000000002
    


## 标题：阅兵方阵

x国要参加同盟阅兵活动。
主办方要求每个加盟国派出的士兵恰好能组成 2 个方阵。
x国发现弱小的 y国派出了130人的队伍，他们的士兵在行进中可以变换2种队形：
 - 130 = 81 + 49 = 9^2 + 7^2
 - 130 = 121 + 9 = 11^2 + 3^2

x国君很受刺激，觉得x国面积是y国的6倍，理应变出更多队形。
于是他发号施令：

我们要派出一支队伍，在行进中要变出 12 种队形！！！

手下人可惨了，要忙着计算至少多少人才能组成 12 种不同的双方阵。
请你利用计算机的优势来计算一下，至少需要多少士兵。

（ps: 不要失去信心，1105人就能组成4种队形了）

注意，需要提交的是一个整数，表示至少需要士兵数目，不要填写任何多余的内容。



```
dic_={}
for i in range(1000):
    for j in range(i,1000):
        if i**2+j**2 not in dic_:
            dic_[i**2+j**2]=[(i,j)]
        else:
            dic_[i**2+j**2].append((i,j))
# print(dic_)
        
```


```
re=[]
for i in dic_:
    if len(dic_[i])==12:
        re.append(i)
print(min(re))
```

    160225
    

## 标题：找假币


```

标题：找假币

在8枚硬币中，有1枚假币，假币外观与真币一模一样，只是重量略轻或略重一点。
给你一架天平，要求最多称3次，就找出假币，并且知道它是重一些还是轻一些。
下面的代码给出一个解决方案，仔细分析逻辑，填写划线位置缺少的代码。

#include <stdio.h>

int balance(int a, int b)
{
	if(a<b) return -1;
	if(a>b) return 1;
	return 0;
}

void judge(char* data, int a, int b, int std)
{
	switch(balance(data[a],data[std])){
	case -1:
		printf("%d light\n", a);
		break;
	case 0:
		printf("%d heavy\n", b);
		break;
	case 1:
		printf("err!\n", b);
	}
}

// data 中8个元素，有一个假币，或轻或重
void f(char* data)
{
	switch(balace(data[0]+data[2]+data[1],data[5]+data[4],data[3]) ____________________________________ ){  // 填空
	case -1:
		switch(balance(data[0]+data[4],data[3]+data[1])){
			case -1:
				judge(data,0,3,1);
				break;
			case 0:
				judge(data,2,5,0);
				break;
			case 1:
				judge(data,1,4,0);
		}
		break;
	case 0:
		judge(data,6,7,0);		
		break;
	case 1:
		switch(balance(data[0]+data[4],data[3]+data[1])){
			case -1:
				judge(data,4,1,0);
				break;
			case 0:
				judge(data,5,2,0);
				break;
			case 1:
				judge(data,3,0,1);
		}
		break;		
	}	
}

int main()
{
	int n;
	char buf[100];
	
	scanf("%d", &n);
	gets(buf);
	
	int i;
	for(i=0; i<n; i++){
		gets(buf);
		f(buf);
	}
	
	return 0;
}

请注意：只需要填写划线部分缺少的内容，不要抄写已有的代码或符号。


```


```
balace(data[0]+data[2]+data[1],data[5]+data[4],data[3])
```


## 标题：约瑟夫环
```
n 个人的编号是 1~n，如果他们依编号按顺时针排成一个圆圈，从编号是1的人开始顺时针报数。
（报数是从1报起）当报到 k 的时候，这个人就退出游戏圈。下一个人重新从1开始报数。
求最后剩下的人的编号。这就是著名的约瑟夫环问题。

本题目就是已知 n，k 的情况下，求最后剩下的人的编号。

题目的输入是一行，2个空格分开的整数n, k
要求输出一个整数，表示最后剩下的人的编号。

约定：0 < n,k < 1百万
```
**例如输入：**
```
10 3
```
**程序应该输出：**
```
4
```
**资源约定：**
```
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms
```

- 请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

**注意：**
```
main函数需要返回0;
只使用ANSI C/ANSI C++ 标准;
不要调用依赖于编译环境或操作系统的特殊函数。
所有依赖的函数必须明确地在源文件中 #include <xxx>
不能通过工程设置而省略常用头文件。

提交程序时，注意选择所期望的语言类型和编译器类型。

```


```
n,k=map(int,input().strip().split())
re=[i for i in range(1,n+1)]
start=0
while len(re)!=1:
    
    for i in range(k-1):
        start=(start+1)%len(re)
    re.pop(start)
    start=start%len(re)
#     print(re)
print(re[0])
```

    10 3
    4
    


## 标题：自描述序列
```
小明在研究一个序列，叫Golomb自描述序列，不妨将其记作{G(n)}。这个序列有2个很有趣的性质:

1. 对于任意正整数n，n在整个序列中恰好出现G(n)次。
2. 这个序列是不下降的。

以下是{G(n)}的前几项：

n	1	2	3	4	5	6	7	8	9	10	11	12	13
G(n)1	2	2	3	3	4	4	4	5	5	5	6	6

给定一个整数n，你能帮小明算出G(n)的值吗？
```
**输入**
```
----
一个整数n。  

对于30%的数据，1 <= n <= 1000000  
对于70%的数据，1 <= n <= 1000000000  
对于100%的数据，1 <= n <= 2000000000000000  
```
**输出**
```
----
一个整数G(n)

```
**【样例输入】**
```
13
```
**【样例输出】**
```
6
```

**资源约定：**
```
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。
```
**注意：**
```
main函数需要返回0;
只使用ANSI C/ANSI C++ 标准;
不要调用依赖于编译环境或操作系统的特殊函数。
所有依赖的函数必须明确地在源文件中 #include <xxx>
不能通过工程设置而省略常用头文件。

提交程序时，注意选择所期望的语言类型和编译器类型。
```



```
n=int(input())
dic_={1:1,2:2}
num=1
i=1
while num<=n:
#     print(dic_)
    for j in range(dic_[i]):
        dic_[num]=i
        num+=1
    i+=1
print(dic_[n])

```

    13
    6
    


## 标题：采油
```
LQ公司是世界著名的石油公司，为世界供应优质石油。
最近，LQ公司又在森林里发现了一大片区域的油田，可以在这个油田中开采n个油井。
LQ公司在这n个油井之间修建了n-1条道路，每条道路连接两个油井，路径中间不会路过任何油井，而且这些道路将所有油井连通。
建立油井的时候需要使用一台大型设备，运输起来非常麻烦，LQ公司准备在其中的一个油井位置建立一个空运站，先将设备空运到空运站，之后每次经过他们建立的道路来运输这个大型设备以建立不同的油井，当油井建立完毕后再从空运站将大型设备运走。
为了减少运输的麻烦，公司要求大型设备在道路上运输的总路程是最短的。

在建立油井和采油的过程中需要花费一些人力，第i个油井需要花费Bi个人，而一旦油井建成，就需要Si个人一直坚守在油井上进行维护。
当然，如果一个人参与了油井的建设，他可以直接留下来维护油井，或者参与下一个油井的建设，但是在维护油井的人不能再参加后续油井的建设了。

现在LQ公司想知道，大型设备运输的总路径长度最短是多少？在保证总路径长度最短的情况下，LQ公司至少需要花费多少人力才能完成所有油井的建立与维护。
```
**【输入格式】**
```
　　输入的第一行包含一个整数n，表示油井的数量。油井由1到n依次标号。
　　第二行包含n个整数，依次表示B1, B2, …, Bn，相邻的整数之间用一个空格分隔。
　　第三行包含n个整数，依次表示S1, S2, …, Sn，相邻的整数之间用一个空格分隔。
　　接下来n-1行描述油井之间的道路，其中的第i行包含两个整数a，b，用一个空格分隔，表示一条道路的起点为i+1、终点为a，长度为b，道路是双向的，设备可以从任意一端运送到另一端，每条道路都可以经过任意多次。数据保证任意两个油井之间都可以通过道路连接。
```
**【输出格式】**
```
　　输出包含两个整数，用一个空格分隔，表示最优情况下大型设备需要运输的总路程，以及在总路程最短的情况下最少需要花费的人力数量。
```
**【样例输入】**
```
2
10 20
15 15
1 8
```
**【样例输出】**
```
16 30
```
**【样例说明】**
```
　　有两种方案达到最优。
　　方案一：在油井2建立空运站，先建立油井2，再将大型设备运输到油井1建立油井1，最后将大型设备运回油井2。
　　方案二：在油井1建立空运站，先将大型设备运输到油井2建立油井2，再将大型设备运送到油井1建立油井1。
```
**【样例输入】**
```
6
3 10 20 7 15 9
2 6 10 4 8 7
1 9
1 2
2 5
3 4
3 7
```
**【样例输出】**
```
54 38
```
**【数据规模和约定】**
```
　　对于20%的数据：n不超过10；
　　另外20%的数据：每个油井最多和两个油井之间有道路直接连接；
　　另外10%的数据：有n-1个油井只有一条道路与其他油井连接；
　　对于100%的数据：n不超过100000，B、S、c均为不超过10000的正整数。
```
**资源约定：**
```
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。
```
**注意：**
```
main函数需要返回0;
只使用ANSI C/ANSI C++ 标准;
不要调用依赖于编译环境或操作系统的特殊函数。
所有依赖的函数必须明确地在源文件中 #include <xxx>
不能通过工程设置而省略常用头文件。

提交程序时，注意选择所期望的语言类型和编译器类型。
```


```
n=int(input())
B_lis=map(int,input().strip().split())
S_lis=map(int,input().strip().split())
map_=[[0 for j in range(n)]for j in range(n) ]
for i in range(1,n):
    a,b=map(int,input().strip().split())
    map_[i][a-1]=b
print(map_)
```

    2
    10 20
    15 15
    1 8
    [[0, 0], [8, 0]]
    


```
int n,l=0,num=0,b,s;

int main(){

    cin>>n;

    for(int i=1;i<=n;i++)

        cin>>b;

    for(int i=1;i<=n;i++){

        cin>>s;

        num+=s;

    }

    for(int i=2;i<=n;i++){

        int a1,a2;

        cin>>a1>>a2;

        l+=a2; 

    }

    cout<<l*2<<" "<<num;

    return 0;

}


```
