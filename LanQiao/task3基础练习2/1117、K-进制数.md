## 题目 1117: K-进制数

时间限制: 1Sec 内存限制: 128MB 提交: 2458 解决: 959

提交地址：

https://www.dotcpp.com/oj/problem1117.html

**题目描述**

> 考虑包含N位数字的K-进制数. 定义一个数有效, 如果其K-进制表示不包含两连续的0.
>
> 考虑包含N位数字的K-进制数. 定义一个数有效, 如果其K-进制表示不包含两连续的0.

**例:**

1010230 是有效的7位数
1000198 无效
0001235 不是7位数, 而是4位数.

给定两个数N和K, 要求计算包含N位数字的有效K-进制数的总数.

假设2 <= K <= 10; 2 <= N; 4 <= N+K <= 18.

**输入**

> 两个十进制整数N和K

**输出**

> 十进制表示的结果

**样例输入**

```python
2
10
```

**样例输出**

```python
90
```
## 提示

> 从n个数中任取k个不相邻的数，求共有多少种不同的方案数？
> 令n=K+h,我们考虑2113从这n个数中取K个不相邻的数的情5261况数：可以理解为插4102空,即用K个元素去插h个元素的空位1653,请注意思考：任何两种不同的插空恰好对应于我们所需要的两种不同的取法.h个元素的空位有h+1个,因此,我们的答案就是：从这h+1个元素中任取K个元素的组合数!
> 前提：n 最小是 2*k-1.
>
> 组合 [(h+1)*h*(h-1)*```````(h+1-k)] /[k*(k-1)*(k-2)*``````1] 
>
> 排列： [(h+1)*h*(h-1)*```````(h+1-k)]

参考答案：

```
N=int(input())
K=int(input())
re1=(K-1)**N
def f (n,k):
    h=n-k
    re=1
    for i in range(1,k+1):
        re*=(h+1-i+1)/i
    return re*((K-1)**(n-k+1))## n-k+1中+1是加上了首位
    
    
re2=sum([f(N-1,k) for k in range(1,int(((N-1)+1)/2)+1)])# 因为首位不能为零，所以从其他位置选取为零的点
print(int(re1+re2))
```

    2
    10
    90